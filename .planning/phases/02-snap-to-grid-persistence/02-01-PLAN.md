---
phase: 02-snap-to-grid-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hooks/usePreviewPersistence.ts
  - components/FloatingWindow.tsx
  - components/NextSlidePreview.tsx
autonomous: true

must_haves:
  truths:
    - "Preview window position and size are saved when tab is hidden or page unloads"
    - "Preview window loads in same position and size on page refresh"
    - "Snap toggle state persists across sessions"
    - "Each presentation remembers its own preview layout"
  artifacts:
    - path: "hooks/usePreviewPersistence.ts"
      provides: "Persistence hook with localStorage save/load"
      exports: ["usePreviewPersistence", "PreviewState"]
    - path: "components/FloatingWindow.tsx"
      provides: "Extended props for controlled position/size and snap toggle"
      min_lines: 200
    - path: "components/NextSlidePreview.tsx"
      provides: "Integration of persistence hook with FloatingWindow"
      min_lines: 100
  key_links:
    - from: "hooks/usePreviewPersistence.ts"
      to: "localStorage"
      via: "getItem/setItem with JSON serialization"
      pattern: "localStorage\\.(get|set)Item"
    - from: "components/NextSlidePreview.tsx"
      to: "hooks/usePreviewPersistence.ts"
      via: "usePreviewPersistence hook call"
      pattern: "usePreviewPersistence"
    - from: "components/NextSlidePreview.tsx"
      to: "components/FloatingWindow.tsx"
      via: "position/size/onPositionChange/onSizeChange props"
      pattern: "position=|size=|onPositionChange|onSizeChange"
---

<objective>
Create persistence infrastructure for preview window state.

Purpose: Enable preview window to remember position, size, and snap toggle state across browser sessions on a per-presentation basis.

Output:
- `usePreviewPersistence` hook with localStorage save/load
- Extended `FloatingWindow` component with controlled position/size props
- Wired `NextSlidePreview` that uses persistence hook
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-snap-to-grid-persistence/02-CONTEXT.md
@.planning/phases/02-snap-to-grid-persistence/02-RESEARCH.md
@components/FloatingWindow.tsx
@components/NextSlidePreview.tsx
@hooks/useViewportBounds.ts
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usePreviewPersistence hook</name>
  <files>hooks/usePreviewPersistence.ts</files>
  <action>
Create a custom hook that manages preview window state with localStorage persistence.

Interface:
```typescript
interface PreviewState {
  x: number;
  y: number;
  width: number;
  height: number;
  snapEnabled: boolean;
}
```

Hook signature:
```typescript
function usePreviewPersistence(
  presentationId: string,
  defaultState: PreviewState
): [PreviewState, (updates: Partial<PreviewState>) => void]
```

Implementation requirements:
1. Storage key format: `pipi-preview-${presentationId}` (use slides[0].id from types.ts)
2. Lazy initialization from localStorage on mount (parse JSON, validate shape)
3. Save to localStorage on:
   - `visibilitychange` event when document becomes hidden
   - `beforeunload` event as backup (desktop browsers)
   - Component unmount
4. Use ref to track latest state for save handlers (avoid stale closures)
5. Wrap JSON.parse in try-catch with fallback to defaultState
6. Validate saved position against current viewport on load:
   - If x + width > window.innerWidth, clamp x to keep window visible
   - If y + height > window.innerHeight, clamp y to keep window visible
   - If width > window.innerWidth, clamp width
   - If height > window.innerHeight, clamp height
7. Return tuple: [state, updateState function]

Pattern reference: See RESEARCH.md "Pattern 3: localStorage Persistence Hook"
  </action>
  <verify>
- File exists at hooks/usePreviewPersistence.ts
- TypeScript compiles without errors: `npx tsc --noEmit`
- Exports both PreviewState interface and usePreviewPersistence function
  </verify>
  <done>
Hook created with localStorage save on visibilitychange/beforeunload, viewport bounds validation on load, and per-presentation storage key support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend FloatingWindow for controlled mode</name>
  <files>components/FloatingWindow.tsx</files>
  <action>
Extend FloatingWindow to support both uncontrolled (current) and controlled position/size modes.

Add new props to FloatingWindowProps interface:
```typescript
// Controlled mode props (optional - if provided, component is controlled)
position?: Position;
size?: Size;
onPositionChange?: (pos: Position) => void;
onSizeChange?: (size: Size) => void;

// Snap support props (for Plan 02)
snapEnabled?: boolean;
onSnapToggle?: () => void;
isDragging?: boolean;
onDragStart?: () => void;
onDragEnd?: () => void;
```

Behavior changes:
1. If `position` prop is provided, use it instead of internal state
2. If `size` prop is provided, use it instead of internal state
3. In controlled mode, call `onPositionChange` and `onSizeChange` callbacks instead of setting internal state
4. Keep backward compatibility: if controlled props are NOT provided, component works exactly as before (uncontrolled mode)
5. Update handleDragStop to call onDragEnd callback if provided
6. Update handleDragStart to call onDragStart callback if provided
7. Pass snapEnabled, onSnapToggle, isDragging through to Rnd - these will be used in Plan 02 for grid snapping

Do NOT implement snap toggle button or grid overlay yet - that's Plan 02.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- Existing NextSlidePreview still works (uncontrolled mode preserved)
  </verify>
  <done>
FloatingWindow supports controlled mode via position/size/onChange props while maintaining backward compatibility with uncontrolled mode.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire NextSlidePreview with persistence</name>
  <files>components/NextSlidePreview.tsx</files>
  <action>
Integrate usePreviewPersistence hook into NextSlidePreview.

Changes:
1. Add `slides` prop to NextSlidePreviewProps (needed to derive presentationId from slides[0].id)
2. Import and call usePreviewPersistence hook:
   ```typescript
   const presentationId = slides.length > 0 ? slides[0].id : 'default';
   const [previewState, updatePreviewState] = usePreviewPersistence(presentationId, {
     x: Math.max(0, window.innerWidth - 220),
     y: Math.max(0, window.innerHeight - 200),
     width: 200,
     height: 150,
     snapEnabled: false,
   });
   ```
3. Remove internal getDefaultPosition function (now from persistence)
4. Pass controlled props to FloatingWindow:
   ```typescript
   <FloatingWindow
     position={{ x: previewState.x, y: previewState.y }}
     size={{ width: previewState.width, height: previewState.height }}
     onPositionChange={(pos) => updatePreviewState({ x: pos.x, y: pos.y })}
     onSizeChange={(size) => updatePreviewState({ width: size.width, height: size.height })}
     snapEnabled={previewState.snapEnabled}
     onSnapToggle={() => updatePreviewState({ snapEnabled: !previewState.snapEnabled })}
     // ... other existing props
   >
   ```
5. Update PresentationView.tsx to pass `slides` prop to NextSlidePreview (add slides to destructured props)

Note: snapEnabled and onSnapToggle are wired but won't have visible effect until Plan 02 adds the toggle button and grid behavior.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- Dev server runs: `npm run dev` - no console errors
- Preview window appears in presentation mode
- After positioning preview and refreshing page, preview appears in saved position
  </verify>
  <done>
NextSlidePreview uses persistence hook. Preview window position, size, and snap toggle state persist across page refreshes with per-presentation storage.
  </done>
</task>

</tasks>

<verification>
1. Start dev server: `npm run dev`
2. Open presentation mode, show preview window
3. Drag preview to a new position, resize it
4. Refresh the page
5. Return to presentation mode, show preview
6. Verify preview appears in the previously saved position and size
7. Open browser DevTools > Application > Local Storage
8. Verify key exists: `pipi-preview-{slide-id}`
9. Delete the localStorage entry, refresh, verify default position is used
</verification>

<success_criteria>
- usePreviewPersistence hook exists and exports PreviewState type
- FloatingWindow supports controlled mode via position/size props
- NextSlidePreview uses persistence hook
- Preview position persists across browser refresh
- Preview size persists across browser refresh
- Different presentations (different first slide IDs) have independent saved positions
- Saved position is validated and adjusted if outside current viewport
</success_criteria>

<output>
After completion, create `.planning/phases/02-snap-to-grid-persistence/02-01-SUMMARY.md`
</output>
