---
phase: 46-preview-edit-trust-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - components/EnhancementPanel.tsx
  - types.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can toggle edit mode on/off in EnhancementPanel"
    - "User can click on any text element and modify its content"
    - "Edits persist when switching between differentiation tabs"
    - "User can discard all edits to revert to AI-generated content"
  artifacts:
    - path: "components/EnhancementPanel.tsx"
      provides: "Edit mode toggle, contenteditable elements, edit state management"
      contains: "isEditMode"
    - path: "types.ts"
      provides: "EditState type for tracking element edits"
      contains: "EditState"
  key_links:
    - from: "EnhancementPanel.tsx"
      to: "useReducer"
      via: "editReducer for state management"
      pattern: "useReducer.*editReducer"
    - from: "contenteditable elements"
      to: "editState"
      via: "EDIT_ELEMENT dispatch"
      pattern: "dispatch.*EDIT_ELEMENT"
---

<objective>
Add edit mode and inline editing capability to EnhancementPanel

Purpose: Teachers need to fix AI wording mistakes, adjust difficulty, or make small corrections before exporting. Inline editing builds trust by giving teachers full control over the final output.

Output: EnhancementPanel with toggle-able edit mode, contenteditable text elements, and edit state persistence across tab switches.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-preview-edit-trust-ui/46-CONTEXT.md
@.planning/phases/46-preview-edit-trust-ui/46-RESEARCH.md
@components/EnhancementPanel.tsx
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EditState types and useReducer structure</name>
  <files>types.ts, components/EnhancementPanel.tsx</files>
  <action>
1. In types.ts, add EditState type after EnhancementOptions:

```typescript
// Edit state for tracking user modifications to enhanced content
export type EditAction =
  | { type: 'EDIT_ELEMENT'; level: 'simple' | 'standard' | 'detailed'; position: number; content: string }
  | { type: 'REVERT_ELEMENT'; level: 'simple' | 'standard' | 'detailed'; position: number }
  | { type: 'DISCARD_ALL' };

export interface EditState {
  // Map: level -> (position -> edited content)
  edits: Record<'simple' | 'standard' | 'detailed', Map<number, string>>;
}
```

2. In EnhancementPanel.tsx, add the editReducer function before the component:

```typescript
const initialEditState: EditState = {
  edits: {
    simple: new Map(),
    standard: new Map(),
    detailed: new Map()
  }
};

function editReducer(state: EditState, action: EditAction): EditState {
  switch (action.type) {
    case 'EDIT_ELEMENT': {
      const newEdits = { ...state.edits };
      newEdits[action.level] = new Map(state.edits[action.level]);
      newEdits[action.level].set(action.position, action.content);
      return { edits: newEdits };
    }
    case 'REVERT_ELEMENT': {
      const newEdits = { ...state.edits };
      newEdits[action.level] = new Map(state.edits[action.level]);
      newEdits[action.level].delete(action.position);
      return { edits: newEdits };
    }
    case 'DISCARD_ALL':
      return initialEditState;
    default:
      return state;
  }
}
```

3. Add state to component:
- Add `const [isEditMode, setIsEditMode] = useState(false);`
- Add `const [editState, dispatch] = useReducer(editReducer, initialEditState);`
- Import useReducer from React

Why useReducer: Complex multi-element editing with interdependencies benefits from centralized state management. See 46-RESEARCH.md Pattern 2-3.
  </action>
  <verify>TypeScript compiles without errors: `cd "/Users/ricky/Documents/App_Projects/Education Apps/DEV - Cue" && npm run build 2>&1 | head -50`</verify>
  <done>EditState type exists in types.ts, editReducer exists in EnhancementPanel.tsx, isEditMode and editState hooked up</done>
</task>

<task type="auto">
  <name>Task 2: Add Edit Mode toggle button and integrate with element rendering</name>
  <files>components/EnhancementPanel.tsx</files>
  <action>
1. Add Edit Mode toggle button in the header area (after the differentiation tabs, before the content):

```tsx
{/* Edit Mode Toggle */}
<div className="flex items-center justify-between mt-4 pt-3 border-t border-slate-200 dark:border-slate-700">
  <div className="flex items-center gap-3">
    <button
      onClick={() => setIsEditMode(!isEditMode)}
      className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${
        isEditMode
          ? 'bg-indigo-100 text-indigo-700 dark:bg-indigo-900/30 dark:text-indigo-400'
          : 'bg-slate-100 text-slate-600 dark:bg-slate-800 dark:text-slate-400 hover:bg-slate-200 dark:hover:bg-slate-700'
      }`}
    >
      <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
      </svg>
      {isEditMode ? 'Editing' : 'Edit'}
    </button>
  </div>

  {/* Show Discard button when edits exist */}
  {isEditMode && hasAnyEdits() && (
    <button
      onClick={() => dispatch({ type: 'DISCARD_ALL' })}
      className="text-sm text-red-500 hover:text-red-600 dark:text-red-400 dark:hover:text-red-300"
    >
      Discard all changes
    </button>
  )}
</div>
```

2. Add hasAnyEdits helper function:
```typescript
const hasAnyEdits = () => {
  return editState.edits.simple.size > 0 ||
         editState.edits.standard.size > 0 ||
         editState.edits.detailed.size > 0;
};
```

3. Modify renderElement to use contenteditable when in edit mode. Update the function signature and add editable wrapper:

```tsx
const renderElement = (element: EnhancedElement, index: number) => {
  const baseClasses = 'mb-4';
  const editedContent = editState.edits[selectedLevel].get(element.position);
  const displayContent = editedContent ?? element.enhancedContent;
  const isEdited = editedContent !== undefined;

  // For non-editable types (visual content), render as before
  if (['diagram', 'image', 'blank-space', 'table'].includes(element.type)) {
    // Keep existing render logic unchanged
    // (tables, diagrams, images, blank-space are not inline-editable)
    return /* existing switch case for these types */;
  }

  // Editable wrapper for text elements
  const editableContent = (content: string, className: string) => {
    if (!isEditMode) {
      return <span>{content}</span>;
    }
    return (
      <div
        role="textbox"
        contentEditable="plaintext-only"
        suppressContentEditableWarning
        aria-label={`Edit ${element.type}`}
        className={`outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 rounded px-1 -mx-1 ${
          isEdited ? 'bg-amber-50 dark:bg-amber-900/20' : ''
        }`}
        onBlur={(e) => {
          const newContent = e.currentTarget.textContent || '';
          if (newContent !== element.enhancedContent) {
            dispatch({
              type: 'EDIT_ELEMENT',
              level: selectedLevel,
              position: element.position,
              content: newContent
            });
          }
        }}
        onKeyDown={(e) => {
          // Prevent Enter from creating new elements
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            e.currentTarget.blur();
          }
        }}
        onPaste={(e) => {
          // Strip formatting, paste plain text only
          e.preventDefault();
          const text = e.clipboardData.getData('text/plain');
          document.execCommand('insertText', false, text);
        }}
      >
        {content}
      </div>
    );
  };

  // Use editableContent wrapper for text types
  switch (element.type) {
    case 'header':
      return (
        <h2 key={index} className={`${baseClasses} text-xl font-bold text-slate-800 dark:text-white font-fredoka`}>
          {editableContent(displayContent, '')}
          {element.slideReference && !isEditMode && (
            <span className="ml-2 text-sm font-normal text-indigo-500 dark:text-indigo-400">
              ({element.slideReference})
            </span>
          )}
        </h2>
      );
    // ... similar pattern for other text types
  }
};
```

IMPORTANT: Only make text content editable (header, subheader, paragraph, instruction, question, answer). Tables, diagrams, images, blank-space remain non-editable.

4. Add visual indicator for edited elements - subtle amber background when content differs from original (shown in editableContent function above with isEdited check).

5. Add Revert button for individual edited elements (appears next to edited elements in edit mode):
```tsx
{isEditMode && isEdited && (
  <button
    onClick={() => dispatch({ type: 'REVERT_ELEMENT', level: selectedLevel, position: element.position })}
    className="ml-2 text-xs text-slate-400 hover:text-slate-600 dark:hover:text-slate-300"
    title="Revert to AI version"
  >
    <svg className="w-4 h-4 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
    </svg>
  </button>
)}
```
  </action>
  <verify>
1. Dev server runs: `cd "/Users/ricky/Documents/App_Projects/Education Apps/DEV - Cue" && npm run dev &`
2. Navigate to editor, upload a resource, run enhancement, verify Edit button appears
3. Click Edit, verify elements become editable
4. Edit text, switch tabs, switch back - verify edit persists
5. Click "Discard all changes" - verify edits cleared
  </verify>
  <done>Edit mode toggle visible, text elements editable when active, edits persist across tab switches, discard button clears all edits</done>
</task>

<task type="auto">
  <name>Task 3: Handle list element editing</name>
  <files>components/EnhancementPanel.tsx</files>
  <action>
Lists need special handling because they have children array. Modify the list case in renderElement:

```tsx
case 'list':
  if (!isEditMode) {
    return (
      <ul key={index} className={`${baseClasses} list-disc pl-6 space-y-1 text-slate-600 dark:text-slate-300`}>
        {element.children?.map((item, i) => (
          <li key={i}>{item}</li>
        )) || <li>{element.enhancedContent}</li>}
      </ul>
    );
  }

  // In edit mode, show as editable text block (one item per line)
  const listContent = editedContent ?? (element.children?.join('\n') || element.enhancedContent);
  return (
    <div key={index} className={baseClasses}>
      <div
        role="textbox"
        contentEditable="plaintext-only"
        suppressContentEditableWarning
        aria-label="Edit list items (one per line)"
        aria-multiline="true"
        className={`list-disc pl-6 space-y-1 text-slate-600 dark:text-slate-300 outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 rounded px-1 -mx-1 whitespace-pre-wrap ${
          isEdited ? 'bg-amber-50 dark:bg-amber-900/20' : ''
        }`}
        onBlur={(e) => {
          const newContent = e.currentTarget.textContent || '';
          const originalContent = element.children?.join('\n') || element.enhancedContent;
          if (newContent !== originalContent) {
            dispatch({
              type: 'EDIT_ELEMENT',
              level: selectedLevel,
              position: element.position,
              content: newContent
            });
          }
        }}
        onPaste={(e) => {
          e.preventDefault();
          const text = e.clipboardData.getData('text/plain');
          document.execCommand('insertText', false, text);
        }}
      >
        {listContent}
      </div>
      {isEdited && (
        <button
          onClick={() => dispatch({ type: 'REVERT_ELEMENT', level: selectedLevel, position: element.position })}
          className="mt-1 text-xs text-slate-400 hover:text-slate-600 dark:hover:text-slate-300"
          title="Revert to AI version"
        >
          Revert list
        </button>
      )}
      <p className="text-xs text-slate-400 mt-1">One item per line</p>
    </div>
  );
```

Note: When exporting (future Phase 47), the list content will need to be split back into array format. For now, store as newline-separated string in edit state.
  </action>
  <verify>
1. Upload a document that produces list elements
2. Enable edit mode
3. Edit list items (modify, add, remove lines)
4. Verify edits persist
5. Verify revert works for lists
  </verify>
  <done>List elements editable as multi-line text, one item per line, with revert capability</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run build`
2. Edit mode toggle appears in enhanced results view
3. Clicking Edit enables contenteditable on text elements
4. Edits show amber background indicator
5. Individual element revert buttons work
6. "Discard all changes" clears all edits across all levels
7. Edits persist when switching between Simple/Standard/Detailed tabs
8. Non-editable elements (tables, images, diagrams) remain read-only
</verification>

<success_criteria>
- User can toggle edit mode on/off with visual feedback
- User can click any text element and modify content inline
- Edited elements show visual indicator (amber background)
- User can revert individual elements or discard all changes
- Edits persist across tab switches (stored per level)
- Lists editable as newline-separated text
- Accessibility: ARIA attributes present on contenteditable elements
</success_criteria>

<output>
After completion, create `.planning/phases/46-preview-edit-trust-ui/46-01-SUMMARY.md`
</output>
