---
phase: 20-game-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - types.ts
  - components/games/GameMenu.tsx
autonomous: true

must_haves:
  truths:
    - "GameType union includes all 4 game types"
    - "Each game type has its own state interface with gameType discriminant"
    - "GameMenu dropdown displays 4 game options with icons"
    - "Clicking dropdown button toggles menu open/closed"
    - "Clicking outside menu closes it"
  artifacts:
    - path: "types.ts"
      provides: "Unified GameState discriminated union types"
      contains: "type GameType = 'quick-quiz' | 'millionaire' | 'the-chase' | 'beat-the-chaser'"
    - path: "components/games/GameMenu.tsx"
      provides: "Toolbar dropdown for game selection"
      exports: ["GameMenu"]
  key_links:
    - from: "types.ts"
      to: "GameMenu.tsx"
      via: "GameType import"
      pattern: "import.*GameType.*from"
---

<objective>
Create the unified game type system and game selection menu dropdown.

Purpose: Establish the foundational type architecture that prevents state silos between game types, and provide the UI entry point for launching games.

Output:
- Extended types.ts with GameType union, BaseGameState, and discriminated union types for all 4 games
- New GameMenu.tsx component with dropdown showing all game options
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-game-foundation/20-CONTEXT.md
@.planning/phases/20-game-foundation/20-RESEARCH.md
@types.ts
@components/ClassBankDropdown.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add unified game type system to types.ts</name>
  <files>types.ts</files>
  <action>
Add the following type definitions to types.ts (keep existing types intact):

1. GameType union:
```typescript
export type GameType = 'quick-quiz' | 'millionaire' | 'the-chase' | 'beat-the-chaser';
```

2. GameStatus for state machine:
```typescript
export type GameStatus = 'loading' | 'splash' | 'playing' | 'reveal' | 'result';
```

3. BaseGameState (shared properties):
```typescript
export interface BaseGameState {
  gameType: GameType;
  status: GameStatus;
  questions: QuizQuestion[];
  currentQuestionIndex: number;
}
```

4. QuickQuizState (extends base, already have similar as GameSyncState):
```typescript
export interface QuickQuizState extends BaseGameState {
  gameType: 'quick-quiz';
  isAnswerRevealed: boolean;
}
```

5. MillionaireState (placeholder for phase 21):
```typescript
export interface MillionaireState extends BaseGameState {
  gameType: 'millionaire';
  selectedOption: number | null;
  lifelines: {
    fiftyFifty: boolean;
    phoneAFriend: boolean;
    askTheAudience: boolean;
  };
  prizeLadder: number[];
  currentPrize: number;
}
```

6. TheChaseState (placeholder for phase 23):
```typescript
export interface TheChaseState extends BaseGameState {
  gameType: 'the-chase';
  chaserPosition: number;
  contestantPosition: number;
  isChasing: boolean;
}
```

7. BeatTheChaserState (placeholder for phase 24):
```typescript
export interface BeatTheChaserState extends BaseGameState {
  gameType: 'beat-the-chaser';
  contestantTime: number;
  chaserTime: number;
  activePlayer: 'contestant' | 'chaser';
}
```

8. Unified GameState union:
```typescript
export type GameState =
  | QuickQuizState
  | MillionaireState
  | TheChaseState
  | BeatTheChaserState;
```

9. Helper for null state (no active game):
```typescript
export type ActiveGameState = GameState | null;
```

10. Update PresentationMessage to use new GameState:
Replace the existing GAME_STATE_UPDATE payload type from GameSyncState to GameState.

11. Add assertNever helper for exhaustive switches:
```typescript
export function assertNever(x: never): never {
  throw new Error(`Unexpected value: ${x}`);
}
```

Note: Keep the existing GameSyncState for backward compatibility during migration (will be removed in Plan 02 after refactoring QuizOverlay).

Import QuizQuestion from geminiService if not already imported for BaseGameState.
  </action>
  <verify>Run `npx tsc --noEmit` to verify types compile without errors</verify>
  <done>All game types defined with discriminated unions, PresentationMessage updated, assertNever helper added</done>
</task>

<task type="auto">
  <name>Task 2: Create GameMenu dropdown component</name>
  <files>components/games/GameMenu.tsx</files>
  <action>
Create new file `components/games/GameMenu.tsx` following the ClassBankDropdown pattern:

```typescript
import React, { useEffect, useRef, useState } from 'react';
import { GameType } from '../../types';

interface GameMenuProps {
  onSelectGame: (type: GameType) => void;
  disabled?: boolean;
}

const GameMenu: React.FC<GameMenuProps> = ({ onSelectGame, disabled }) => {
  const [isOpen, setIsOpen] = useState(false);
  const menuRef = useRef<HTMLDivElement>(null);

  // Close on click outside
  useEffect(() => {
    if (!isOpen) return;
    const handleClick = (e: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClick);
    return () => document.removeEventListener('mousedown', handleClick);
  }, [isOpen]);

  // Close on escape key
  useEffect(() => {
    if (!isOpen) return;
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        setIsOpen(false);
      }
    };
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen]);

  const games: { type: GameType; icon: string; name: string; description: string }[] = [
    { type: 'quick-quiz', icon: 'üéØ', name: 'Quick Quiz', description: 'Kahoot-style questions' },
    { type: 'millionaire', icon: 'üí∞', name: 'Millionaire', description: '15 questions to the top' },
    { type: 'the-chase', icon: 'üèÉ', name: 'The Chase', description: 'Outrun the chaser' },
    { type: 'beat-the-chaser', icon: '‚ö°', name: 'Beat the Chaser', description: 'Race against time' },
  ];

  return (
    <div ref={menuRef} className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        disabled={disabled}
        className={`px-3 py-1.5 rounded-lg text-xs font-bold uppercase tracking-wider
          transition-colors border bg-indigo-600 border-indigo-500 hover:bg-indigo-500
          text-white shadow-lg shadow-indigo-500/30 flex items-center gap-2
          ${disabled ? 'opacity-50 cursor-not-allowed' : ''}`}
      >
        <span>üéÆ</span> Game Mode
        <svg
          className={`w-3 h-3 transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`}
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
        </svg>
      </button>

      {isOpen && (
        <div className="absolute top-full right-0 mt-2 w-56 bg-white dark:bg-slate-800
          rounded-xl shadow-xl border border-slate-200 dark:border-slate-700
          overflow-hidden z-[100] animate-fade-in">

          {/* Header */}
          <div className="px-4 py-2 border-b border-slate-100 dark:border-slate-700">
            <span className="text-[10px] font-bold text-slate-400 dark:text-slate-500 uppercase tracking-widest">
              Select Game
            </span>
          </div>

          {/* Game options */}
          {games.map(game => (
            <button
              key={game.type}
              onClick={() => {
                onSelectGame(game.type);
                setIsOpen(false);
              }}
              className="w-full px-4 py-3 text-left flex items-center gap-3
                hover:bg-slate-50 dark:hover:bg-slate-700 transition-colors group"
            >
              <span className="text-2xl">{game.icon}</span>
              <div className="min-w-0">
                <span className="font-bold text-slate-700 dark:text-slate-200 block">
                  {game.name}
                </span>
                <span className="text-xs text-slate-400 dark:text-slate-500">
                  {game.description}
                </span>
              </div>
              <svg
                className="w-4 h-4 text-slate-300 dark:text-slate-600 group-hover:text-indigo-500
                  dark:group-hover:text-amber-400 transition-colors shrink-0 ml-auto"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
              </svg>
            </button>
          ))}
        </div>
      )}
    </div>
  );
};

export default GameMenu;
```

Create the `components/games/` directory if it doesn't exist.

Style notes per CONTEXT.md:
- Icons + names for each game (all 4 always enabled)
- Direct launch when clicking (no setup screen first ‚Äî that's handled by the game component)
- Match existing dropdown styling from ClassBankDropdown
  </action>
  <verify>File exists at components/games/GameMenu.tsx and exports GameMenu component</verify>
  <done>GameMenu component created with dropdown showing all 4 game options</done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] types.ts contains GameType, GameStatus, BaseGameState, and all 4 game state types
- [ ] types.ts contains unified GameState discriminated union
- [ ] components/games/GameMenu.tsx exists and exports GameMenu
- [ ] GameMenu imports GameType from types.ts
</verification>

<success_criteria>
- TypeScript compiles without errors
- GameType union has all 4 game types
- Each game has its own interface extending BaseGameState with unique discriminant
- GameMenu dropdown displays all 4 options with icons and descriptions
- Clicking outside dropdown closes it
</success_criteria>

<output>
After completion, create `.planning/phases/20-game-foundation/20-01-SUMMARY.md`
</output>
