---
phase: 23-the-chase
plan: 07
type: execute
wave: 4
depends_on: ["23-03", "23-04", "23-05", "23-06"]
files_modified:
  - components/games/TheChaseGame.tsx
  - components/games/GameContainer.tsx
  - components/PresentationView.tsx
autonomous: true

must_haves:
  truths:
    - "TheChaseGame orchestrates all game phases in sequence"
    - "Game flows: Cash Builder -> Offer Selection -> Head-to-Head -> Final Chase"
    - "GameContainer routes to TheChaseGame with proper handlers"
    - "PresentationView launches The Chase with question generation"
    - "Teacher can select Easy/Medium/Hard difficulty before game starts"
    - "Teacher can toggle between AI-controlled and manual chaser mode"
  artifacts:
    - path: "components/games/TheChaseGame.tsx"
      provides: "Main game orchestrator with phase management"
      min_lines: 200
    - path: "components/games/GameContainer.tsx"
      provides: "Routing for Chase game handlers"
      contains: "TheChaseGame"
    - path: "components/PresentationView.tsx"
      provides: "Chase game launch with state factory and difficulty/control mode selection"
      contains: "launchTheChase"
  key_links:
    - from: "components/games/TheChaseGame.tsx"
      to: "components/games/the-chase/CashBuilderRound.tsx"
      via: "phase rendering"
      pattern: "CashBuilderRound"
    - from: "components/PresentationView.tsx"
      to: "services/aiProvider.ts"
      via: "question generation"
      pattern: "generateGameQuestions"
---

<objective>
Integrate all Chase components into a complete game flow with proper orchestration.

Purpose: TheChaseGame needs to manage phase transitions from Cash Builder through Final Chase. GameContainer and PresentationView need updates to launch and handle The Chase properly. Teacher must be able to select difficulty (affects chaser accuracy: Easy=60%, Medium=75%, Hard=90%) AND choose between AI-controlled or manual (teacher-controlled) chaser mode.

Output: Complete TheChaseGame orchestrator, updated GameContainer routing, PresentationView launch logic with difficulty selection modal including AI/manual toggle.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-the-chase/23-CONTEXT.md
@.planning/phases/23-the-chase/23-03-SUMMARY.md
@.planning/phases/23-the-chase/23-04-SUMMARY.md
@.planning/phases/23-the-chase/23-05-SUMMARY.md
@.planning/phases/23-the-chase/23-06-SUMMARY.md
@components/games/GameContainer.tsx
@components/PresentationView.tsx
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TheChaseGame orchestrator component</name>
  <files>components/games/TheChaseGame.tsx</files>
  <action>
Replace the placeholder TheChaseGame with full implementation:

```typescript
import React, { useState, useCallback } from 'react';
import { TheChaseState, ChasePhase, ChaseOffer } from '../../types';
import CashBuilderRound from './the-chase/CashBuilderRound';
import OfferSelection from './the-chase/OfferSelection';
import HeadToHeadRound from './the-chase/HeadToHeadRound';
import FinalChaseRound from './the-chase/FinalChaseRound';
import GameOutcome from './the-chase/GameOutcome';
import GameSplash from './shared/GameSplash';

interface TheChaseGameProps {
  state: TheChaseState;
  onClose: () => void;
  onStateUpdate: (updates: Partial<TheChaseState>) => void;
  onRestart?: () => void;
}

const TheChaseGame: React.FC<TheChaseGameProps> = ({
  state,
  onClose,
  onStateUpdate,
  onRestart
}) => {
  // Local UI state for outcomes
  const [showOutcome, setShowOutcome] = useState<'caught' | 'safe' | null>(null);
  const [finalOutcome, setFinalOutcome] = useState<'win' | 'loss' | null>(null);

  // Phase transition handlers
  const handleCashBuilderComplete = useCallback((score: number) => {
    onStateUpdate({
      phase: 'offer-selection',
      cashBuilderScore: score
    });
  }, [onStateUpdate]);

  const handleOfferSelected = useCallback((offer: ChaseOffer, startPosition: number) => {
    onStateUpdate({
      phase: 'head-to-head',
      selectedOfferIndex: state.offers.findIndex(o => o.amount === offer.amount),
      contestantPosition: startPosition,
      chaserPosition: 0
    });
  }, [onStateUpdate, state.offers]);

  const handleHeadToHeadComplete = useCallback((outcome: 'caught' | 'safe', contestantPosition: number) => {
    if (outcome === 'caught') {
      setShowOutcome('caught');
    } else {
      // Calculate head start based on how far contestant got
      // More steps to home = bigger head start
      const stepsToHome = 6 - contestantPosition;
      onStateUpdate({
        phase: 'final-chase-contestant',
        contestantPosition,
        finalChaseContestantScore: 0,
        finalChaseContestantTime: 120,
        finalChaseChaserScore: 0,
        finalChaseChaserTime: 120,
        chaserTargetScore: stepsToHome // Head start becomes target modifier
      });
    }
  }, [onStateUpdate]);

  const handleFinalChaseComplete = useCallback((outcome: 'win' | 'loss', contestantScore: number, chaserScore: number) => {
    setFinalOutcome(outcome);
    onStateUpdate({
      phase: 'game-over',
      finalChaseContestantScore: contestantScore,
      finalChaseChaserScore: chaserScore,
      status: 'result'
    });
  }, [onStateUpdate]);

  const handleOutcomeDismiss = useCallback(() => {
    if (showOutcome === 'caught') {
      onStateUpdate({ phase: 'game-over', status: 'result' });
    }
    setShowOutcome(null);
  }, [showOutcome, onStateUpdate]);

  const handleContinueToFinal = useCallback(() => {
    setShowOutcome(null);
  }, []);

  // Render based on current phase
  const renderPhase = () => {
    // Show splash during loading
    if (state.status === 'loading' || state.status === 'splash') {
      return <GameSplash gameType="the-chase" />;
    }

    // Show outcomes if triggered
    if (showOutcome) {
      return (
        <GameOutcome
          outcome={showOutcome}
          prizeAmount={state.cashBuilderScore * (state.selectedOfferIndex !== null ? [2, 1, 0.5][state.selectedOfferIndex] : 1)}
          onContinue={showOutcome === 'safe' ? handleContinueToFinal : undefined}
          onPlayAgain={onRestart}
          onExit={onClose}
        />
      );
    }

    if (finalOutcome) {
      return (
        <GameOutcome
          outcome={finalOutcome === 'win' ? 'safe' : 'caught'}
          prizeAmount={state.cashBuilderScore * (state.selectedOfferIndex !== null ? [2, 1, 0.5][state.selectedOfferIndex] : 1)}
          onPlayAgain={onRestart}
          onExit={onClose}
        />
      );
    }

    switch (state.phase) {
      case 'cash-builder':
        return (
          <CashBuilderRound
            questions={state.questions}
            onComplete={handleCashBuilderComplete}
            onExit={onClose}
          />
        );

      case 'offer-selection':
        return (
          <OfferSelection
            cashBuilderScore={state.cashBuilderScore}
            onOfferSelected={handleOfferSelected}
            onExit={onClose}
          />
        );

      case 'head-to-head':
        return (
          <HeadToHeadRound
            questions={state.questions.slice(10)} // Use questions after Cash Builder's
            startingPosition={state.contestantPosition}
            chaserDifficulty={state.chaserDifficulty}
            isAIControlled={state.isAIControlled}
            prizeAmount={state.cashBuilderScore * (state.selectedOfferIndex !== null ? [2, 1, 0.5][state.selectedOfferIndex] : 1)}
            onComplete={handleHeadToHeadComplete}
            onExit={onClose}
          />
        );

      case 'final-chase-contestant':
      case 'final-chase-chaser':
        return (
          <FinalChaseRound
            questions={state.questions.slice(20)} // Use remaining questions
            headStart={state.chaserTargetScore}
            chaserDifficulty={state.chaserDifficulty}
            isAIControlled={state.isAIControlled}
            prizeAmount={state.cashBuilderScore * (state.selectedOfferIndex !== null ? [2, 1, 0.5][state.selectedOfferIndex] : 1)}
            onComplete={handleFinalChaseComplete}
            onExit={onClose}
          />
        );

      case 'game-over':
        return (
          <div className="h-full w-full bg-slate-900 flex items-center justify-center">
            <div className="text-center">
              <div className="text-8xl mb-6">{state.finalChaseChaserScore < state.chaserTargetScore ? 'ðŸ†' : 'ðŸ˜ˆ'}</div>
              <h2 className="text-5xl font-black text-white mb-4">
                {state.finalChaseChaserScore < state.chaserTargetScore ? 'YOU WIN!' : 'Chaser Wins'}
              </h2>
              <div className="flex gap-4 justify-center mt-8">
                {onRestart && (
                  <button
                    onClick={onRestart}
                    className="px-8 py-4 bg-indigo-600 hover:bg-indigo-500 text-white font-bold text-xl rounded-xl"
                  >
                    Play Again
                  </button>
                )}
                <button
                  onClick={onClose}
                  className="px-8 py-4 bg-white text-slate-900 font-bold text-xl rounded-xl"
                >
                  Back to Lesson
                </button>
              </div>
            </div>
          </div>
        );

      default:
        return <GameSplash gameType="the-chase" />;
    }
  };

  return (
    <div className="w-full h-full">
      {renderPhase()}
    </div>
  );
};

export default TheChaseGame;
```
  </action>
  <verify>Run `npm run build` - should compile without errors</verify>
  <done>TheChaseGame orchestrates all phases with proper transitions and state updates</done>
</task>

<task type="auto">
  <name>Task 2: Update GameContainer and PresentationView for Chase integration with difficulty and control mode selection</name>
  <files>components/games/GameContainer.tsx, components/PresentationView.tsx</files>
  <action>
**Update GameContainer.tsx:**

Add Chase-specific handlers to props and route to TheChaseGame:

```typescript
interface GameContainerProps {
  state: GameState;
  onClose: () => void;
  onRevealAnswer: () => void;
  onNextQuestion: () => void;
  onRestart?: () => void;
  // Millionaire-specific handlers (existing)
  onMillionaireSelectOption?: (idx: number) => void;
  onMillionaireLockIn?: () => void;
  onMillionaireNext?: () => void;
  onMillionaireUseLifeline?: (lifeline: 'fiftyFifty' | 'askTheAudience' | 'phoneAFriend') => void;
  isLifelineLoading?: 'phoneAFriend' | null;
  // Chase-specific handlers (new)
  onChaseStateUpdate?: (updates: Partial<TheChaseState>) => void;
}
```

Update the case for 'the-chase':
```typescript
case 'the-chase':
  return (
    <TheChaseGame
      state={state}
      onClose={onClose}
      onStateUpdate={onChaseStateUpdate || (() => {})}
      onRestart={onRestart}
    />
  );
```

**Update PresentationView.tsx:**

1. Add state for Chase setup modal and control mode toggle:
```typescript
const [showChaseSetup, setShowChaseSetup] = useState(false);
const [chaseControlMode, setChaseControlMode] = useState<'ai' | 'manual'>('ai');
```

2. Update createChaseState factory to accept isAIControlled parameter:
```typescript
const createChaseState = useCallback((questions: QuizQuestion[], difficulty: 'easy' | 'medium' | 'hard', isAIControlled: boolean): TheChaseState => ({
  gameType: 'the-chase',
  status: 'playing',
  questions,
  currentQuestionIndex: 0,
  phase: 'cash-builder',
  cashBuilderScore: 0,
  cashBuilderTimeRemaining: 60,
  offers: [],
  selectedOfferIndex: null,
  votes: {},
  isVotingOpen: false,
  contestantPosition: 4, // Middle position default
  chaserPosition: 0,
  chaserDifficulty: difficulty,
  isAIControlled, // Now passed as parameter instead of hardcoded
  isChaserThinking: false,
  finalChaseContestantScore: 0,
  finalChaseContestantTime: 120,
  finalChaseChaserScore: 0,
  finalChaseChaserTime: 120,
  chaserTargetScore: 0,
  currentQuestionAnswered: false,
  contestantAnswer: null,
  chaserAnswer: null,
  showChaserAnswer: false,
}), []);
```

3. Update launchTheChase function to accept and pass isAIControlled:
```typescript
const launchTheChase = useCallback(async (difficulty: 'easy' | 'medium' | 'hard', isAIControlled: boolean) => {
  if (!provider) {
    onRequestAI('start The Chase game');
    return;
  }

  // Show loading state
  setActiveGame({
    ...createChaseState([], difficulty, isAIControlled),
    status: 'loading'
  } as TheChaseState);

  try {
    const slideContext = buildSlideContext(slides, currentIndex);
    const request: GameQuestionRequest = {
      gameType: 'the-chase',
      difficulty,
      questionCount: 40, // Need many questions for all phases
      slideContext,
    };

    const questions = await withRetry<QuizQuestion[]>(
      () => provider.generateGameQuestions(request),
      3,
      1000
    );

    if (questions.length === 0) {
      throw new AIProviderError('No questions generated', 'PARSE_ERROR');
    }

    setActiveGame(createChaseState(questions, difficulty, isAIControlled));
  } catch (e) {
    console.error(e);
    if (e instanceof AIProviderError) {
      onError('Quiz Generation Failed', e.userMessage);
    } else {
      onError('Quiz Generation Failed', 'An unexpected error occurred');
    }
    setActiveGame(null);
  }
}, [provider, slides, currentIndex, createChaseState, onRequestAI, onError]);
```

4. Add Chase state update handler:
```typescript
const handleChaseStateUpdate = useCallback((updates: Partial<TheChaseState>) => {
  setActiveGame(prev => prev && prev.gameType === 'the-chase'
    ? { ...prev, ...updates }
    : prev
  );
}, []);
```

5. Update handleSelectGame to show setup modal for 'the-chase':
```typescript
} else if (gameType === 'the-chase') {
  // Show difficulty and control mode selection modal
  setChaseControlMode('ai'); // Reset to default
  setShowChaseSetup(true);
}
```

6. Add difficulty and control mode selection modal JSX (render near the Millionaire setup modal):
```tsx
{/* Chase Setup Modal - Difficulty and Control Mode Selection */}
{showChaseSetup && (
  <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
    <div className="bg-slate-800 rounded-2xl p-8 max-w-md w-full mx-4 border border-slate-700">
      <h2 className="text-2xl font-bold text-white mb-2">The Chase</h2>
      <p className="text-slate-400 mb-6">Configure the chaser settings</p>

      {/* Control Mode Toggle */}
      <div className="mb-6">
        <label className="text-sm font-medium text-slate-300 mb-3 block">Chaser Control Mode</label>
        <div className="flex gap-2">
          <button
            onClick={() => setChaseControlMode('ai')}
            className={`flex-1 p-3 rounded-xl font-medium transition-colors ${
              chaseControlMode === 'ai'
                ? 'bg-indigo-600 text-white'
                : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
            }`}
          >
            <div className="text-lg">AI-Controlled</div>
            <div className="text-xs opacity-80">Chaser answers automatically</div>
          </button>
          <button
            onClick={() => setChaseControlMode('manual')}
            className={`flex-1 p-3 rounded-xl font-medium transition-colors ${
              chaseControlMode === 'manual'
                ? 'bg-indigo-600 text-white'
                : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
            }`}
          >
            <div className="text-lg">Manual Control</div>
            <div className="text-xs opacity-80">Teacher controls chaser</div>
          </button>
        </div>
      </div>

      {/* Difficulty Selection */}
      <label className="text-sm font-medium text-slate-300 mb-3 block">
        {chaseControlMode === 'ai' ? 'AI Difficulty (accuracy)' : 'Difficulty Level'}
      </label>
      <div className="space-y-3">
        <button
          onClick={() => { setShowChaseSetup(false); launchTheChase('easy', chaseControlMode === 'ai'); }}
          className="w-full p-4 bg-green-600 hover:bg-green-500 text-white rounded-xl font-bold text-lg transition-colors"
        >
          <div>Easy</div>
          <div className="text-sm font-normal opacity-80">
            {chaseControlMode === 'ai' ? 'Chaser gets 60% correct' : 'Easier questions'}
          </div>
        </button>

        <button
          onClick={() => { setShowChaseSetup(false); launchTheChase('medium', chaseControlMode === 'ai'); }}
          className="w-full p-4 bg-amber-600 hover:bg-amber-500 text-white rounded-xl font-bold text-lg transition-colors"
        >
          <div>Medium</div>
          <div className="text-sm font-normal opacity-80">
            {chaseControlMode === 'ai' ? 'Chaser gets 75% correct' : 'Moderate questions'}
          </div>
        </button>

        <button
          onClick={() => { setShowChaseSetup(false); launchTheChase('hard', chaseControlMode === 'ai'); }}
          className="w-full p-4 bg-red-600 hover:bg-red-500 text-white rounded-xl font-bold text-lg transition-colors"
        >
          <div>Hard</div>
          <div className="text-sm font-normal opacity-80">
            {chaseControlMode === 'ai' ? 'Chaser gets 90% correct' : 'Challenging questions'}
          </div>
        </button>
      </div>

      <button
        onClick={() => setShowChaseSetup(false)}
        className="w-full mt-4 p-3 bg-slate-700 hover:bg-slate-600 text-slate-300 rounded-xl transition-colors"
      >
        Cancel
      </button>
    </div>
  </div>
)}
```

7. Pass handler to GameContainer:
```typescript
<GameContainer
  // ... existing props
  onChaseStateUpdate={handleChaseStateUpdate}
/>
```

Import the new Chase types at the top of PresentationView.tsx:
```typescript
import { TheChaseState, ChasePhase } from '../types';
```
  </action>
  <verify>Run `npm run build` - should compile without errors</verify>
  <done>GameContainer routes to TheChaseGame, PresentationView launches Chase with difficulty selection modal AND AI/manual control mode toggle</done>
</task>

</tasks>

<verification>
- `npm run build` passes with no TypeScript errors
- Selecting "The Chase" from GameMenu shows setup modal
- Modal displays AI-Controlled / Manual Control toggle (AI-Controlled selected by default)
- Modal displays Easy (60%), Medium (75%), Hard (90%) difficulty options with descriptions
- Descriptions update based on control mode (AI accuracy vs question difficulty)
- Selecting a difficulty launches the game with correct `isAIControlled` value
- When AI-Controlled: chaser answers automatically based on accuracy
- When Manual Control: teacher controls chaser answers via UI buttons
- Cash Builder starts after loading
- Offer Selection follows Cash Builder
- Head-to-Head follows Offer Selection (respects control mode)
- Final Chase follows successful Head-to-Head (respects control mode)
- Game ends with proper outcome screen
</verification>

<success_criteria>
- TheChaseGame manages all 4 phases with proper transitions
- Phase state updates broadcast to student view
- GameContainer properly routes Chase game type
- PresentationView generates ~40 questions for full game
- Setup modal appears before game launch with two sections:
  1. Control mode toggle (AI-Controlled vs Manual Control)
  2. Difficulty selection (Easy/Medium/Hard)
- AI-Controlled is the default selection
- Teacher can toggle to Manual Control before launching
- Selected control mode sets `isAIControlled` in game state
- Selected difficulty affects chaser accuracy (AI mode) or question difficulty (manual mode)
- Complete game flow works: Cash Builder -> Offers -> Head-to-Head -> Final Chase
</success_criteria>

<output>
After completion, create `.planning/phases/23-the-chase/23-07-SUMMARY.md`
</output>
