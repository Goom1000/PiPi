---
phase: 17-targeting-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - components/PresentationView.tsx
autonomous: true

must_haves:
  truths:
    - "Shuffle function produces unbiased random order"
    - "Cycling state tracks all students with grades"
    - "Next student can be retrieved with their grade level"
    - "Advancing cycles to next student or reshuffles when complete"
  artifacts:
    - path: "components/PresentationView.tsx"
      provides: "Cycling state types, shuffle utility, cycling helper functions"
      contains: "shuffleArray, TargetedCyclingState, initializeCycling, getNextStudent, advanceCycling"
  key_links:
    - from: "initializeCycling"
      to: "shuffleArray"
      via: "Uses shuffle on student names"
      pattern: "shuffleArray.*map.*name"
    - from: "advanceCycling"
      to: "initializeCycling"
      via: "Reshuffles when cycle complete"
      pattern: "if.*>=.*length.*initializeCycling"
---

<objective>
Build cycling state infrastructure for targeted questioning mode

Purpose: Create the data structures and utility functions needed for fair student cycling. Students with grades must be cycled in random order with automatic reshuffle when all have been asked.

Output: TypeScript types and pure functions for cycling logic, added to PresentationView.tsx above component.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/17-targeting-mode/17-CONTEXT.md
@.planning/phases/17-targeting-mode/17-RESEARCH.md

@types.ts (GradeLevel, StudentWithGrade types)
@components/PresentationView.tsx (existing component structure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add shuffle utility and cycling types</name>
  <files>components/PresentationView.tsx</files>
  <action>
Add the following code ABOVE the QuizOverlay component (near the top of the file, after imports):

1. Fisher-Yates shuffle utility function:
```typescript
// Fisher-Yates shuffle - unbiased O(n) randomization
function shuffleArray<T>(array: T[]): T[] {
  const result = [...array];
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}
```

2. Cycling state interface:
```typescript
// Targeted mode cycling state - tracks student order and progress
interface TargetedCyclingState {
  shuffledOrder: string[];     // All students with grades in random order
  currentIndex: number;        // Index of next student to ask
  askedStudents: Set<string>;  // For manual marking (voluntary answers)
}
```

Import StudentWithGrade from '../types' if not already imported.
  </action>
  <verify>File compiles without TypeScript errors: `npm run build` succeeds</verify>
  <done>shuffleArray function and TargetedCyclingState interface exist in PresentationView.tsx</done>
</task>

<task type="auto">
  <name>Task 2: Add cycling helper functions</name>
  <files>components/PresentationView.tsx</files>
  <action>
Add below the TargetedCyclingState interface:

1. Initialize cycling state from student data:
```typescript
// Initialize shuffled cycling from students with grades
function initializeCycling(studentData: StudentWithGrade[]): TargetedCyclingState {
  const studentsWithGrades = studentData.filter(s => s.grade !== null);

  if (studentsWithGrades.length === 0) {
    return { shuffledOrder: [], currentIndex: 0, askedStudents: new Set() };
  }

  return {
    shuffledOrder: shuffleArray(studentsWithGrades.map(s => s.name)),
    currentIndex: 0,
    askedStudents: new Set(),
  };
}
```

2. Get next student with their grade:
```typescript
// Get next student name and grade level for questioning
function getNextStudent(
  cyclingState: TargetedCyclingState,
  studentData: StudentWithGrade[]
): { name: string; grade: GradeLevel } | null {
  const { shuffledOrder, currentIndex } = cyclingState;

  if (shuffledOrder.length === 0 || currentIndex >= shuffledOrder.length) {
    return null;
  }

  const name = shuffledOrder[currentIndex];
  const student = studentData.find(s => s.name === name);

  return student && student.grade ? { name, grade: student.grade } : null;
}
```

3. Advance to next student with auto-reshuffle:
```typescript
// Advance cycling state, reshuffle when cycle complete
function advanceCycling(
  prev: TargetedCyclingState,
  studentData: StudentWithGrade[]
): TargetedCyclingState {
  const newIndex = prev.currentIndex + 1;

  // If all students asked, reshuffle and restart
  if (newIndex >= prev.shuffledOrder.length) {
    return initializeCycling(studentData);
  }

  return {
    ...prev,
    currentIndex: newIndex,
    askedStudents: new Set([...prev.askedStudents, prev.shuffledOrder[prev.currentIndex]]),
  };
}
```

Import GradeLevel from '../types' if not already imported.
  </action>
  <verify>File compiles: `npm run build` succeeds. Functions are pure (no side effects) and handle edge cases (empty array, no grades).</verify>
  <done>initializeCycling, getNextStudent, and advanceCycling functions exist and handle empty/edge cases</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npm run build` succeeds without errors
2. PresentationView.tsx contains:
   - shuffleArray generic function
   - TargetedCyclingState interface
   - initializeCycling function
   - getNextStudent function
   - advanceCycling function
3. All functions are defined above the component (module scope)
4. Types imported from '../types': GradeLevel, StudentWithGrade
</verification>

<success_criteria>
- Fisher-Yates shuffle correctly randomizes arrays (verified by code review)
- Cycling state interface matches RESEARCH.md specification
- initializeCycling filters students without grades
- getNextStudent returns null when cycle exhausted
- advanceCycling calls initializeCycling when all students asked (auto-reshuffle)
- No runtime errors when studentData is empty
</success_criteria>

<output>
After completion, create `.planning/phases/17-targeting-mode/17-01-SUMMARY.md`
</output>
