---
phase: 22-ai-integration
plan: 03
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - services/providers/claudeProvider.ts
autonomous: true

must_haves:
  truths:
    - "ClaudeProvider implements generateGameQuestions matching GeminiProvider behavior"
    - "Claude uses tool_use pattern for structured JSON output"
    - "Millionaire questions have progressive difficulty"
    - "Chase questions have consistent difficulty"
  artifacts:
    - path: "services/providers/claudeProvider.ts"
      provides: "ClaudeProvider.generateGameQuestions implementation"
      contains: "generateGameQuestions"
  key_links:
    - from: "services/providers/claudeProvider.ts"
      to: "services/aiProvider.ts"
      via: "type imports"
      pattern: "import.*GameQuestionRequest.*BLOOM_DIFFICULTY_MAP"
---

<objective>
Implement game-specific question generation in the Claude provider with the same Bloom's taxonomy difficulty progression.

Purpose: Claude is the secondary AI provider. Users who choose Claude should get the same question quality and difficulty progression as Gemini users.

Output:
- generateGameQuestions method in ClaudeProvider
- Same prompt logic as Gemini but using Claude's tool_use pattern
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/22-ai-integration/22-CONTEXT.md
@.planning/phases/22-ai-integration/22-RESEARCH.md
@.planning/phases/22-ai-integration/22-01-SUMMARY.md
@services/providers/claudeProvider.ts
@services/aiProvider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement generateGameQuestions in ClaudeProvider</name>
  <files>services/providers/claudeProvider.ts</files>
  <action>
1. Add imports for new types (update the import from aiProvider):
```typescript
import { AIProviderInterface, AIProviderError, USER_ERROR_MESSAGES, GenerationInput, GameQuestionRequest, BLOOM_DIFFICULTY_MAP } from '../aiProvider';
```

2. Add helper function for Millionaire progression (before ClaudeProvider class):
```typescript
function getMillionaireProgressionRules(count: 3 | 5 | 10): string {
  if (count === 3) {
    return `
Question 1: EASY (Remember/Understand) - "What is...", "Name the..."
Question 2: MEDIUM (Apply/Analyze) - "How would...", "What would happen..."
Question 3: HARD (Evaluate/Create) - "Why does...", "What is the best..."`;
  }
  if (count === 5) {
    return `
Questions 1-2: EASY (Remember/Understand) - "What is...", "Name the..."
Questions 3-4: MEDIUM (Apply/Analyze) - "How would...", "What would happen..."
Question 5: HARD (Evaluate/Create) - "Why does...", "What is the best..."`;
  }
  return `
Questions 1-3: EASY (Remember/Understand) - "What is...", "Name the..."
Questions 4-6: MEDIUM (Apply/Analyze) - "How would...", "What would happen..."
Questions 7-10: HARD (Evaluate/Create) - "Why does...", "What is the best..."`;
}
```

3. Add generateGameQuestions method to ClaudeProvider class (after generateQuestionWithAnswer):
```typescript
  async generateGameQuestions(
    request: GameQuestionRequest
  ): Promise<QuizQuestion[]> {
    // Build system prompt based on game type
    let systemPrompt: string;

    if (request.gameType === 'millionaire') {
      systemPrompt = `You are a quiz master creating "Who Wants to Be a Millionaire" style questions for Year 6 students (10-11 years old).

PROGRESSIVE DIFFICULTY RULES (Bloom's Taxonomy):
${getMillionaireProgressionRules(request.questionCount as 3 | 5 | 10)}

DISTRACTOR RULES (CRITICAL):
- All 4 options must be similar in length and specificity
- Distractors must be plausible misconceptions a student might have
- Never include "All of the above" or "None of the above"
- Avoid using negatives in questions ("Which is NOT...")

CONTENT CONSTRAINT (CRITICAL):
- Generate questions ONLY from the provided lesson content
- Do NOT use external knowledge beyond what is in the slides
- If content is thin, focus on what IS there rather than inventing new facts`;
    } else {
      const difficultyConfig = BLOOM_DIFFICULTY_MAP[request.difficulty];
      systemPrompt = `You are a quiz master creating rapid-fire questions for "The Chase" style game for Year 6 students (10-11 years old).

DIFFICULTY: ${request.difficulty.toUpperCase()}
${difficultyConfig.description}
Question types: ${difficultyConfig.questionTypes}

ALL questions must be at ${request.difficulty} level. No progression - consistent difficulty throughout.

QUICK-FIRE RULES:
- Questions should be answerable in 5-10 seconds
- Single concept per question, no multi-part questions
- Avoid ambiguous wording
- Keep options short (1-5 words each when possible)

DISTRACTOR RULES:
- All 4 options must be plausible
- Distractors should reflect common misconceptions
- Similar length and specificity across all options

CONTENT CONSTRAINT (CRITICAL):
- Generate questions ONLY from the provided lesson content
- Do NOT use external knowledge beyond what is in the slides`;
    }

    // Build user prompt with slide context
    let userPrompt = `LESSON CONTENT (Generate questions from this material only):
Topic: ${request.slideContext.lessonTopic}

${request.slideContext.cumulativeContent}

Current slide focus: ${request.slideContext.currentSlideTitle}
Key points: ${request.slideContext.currentSlideContent.join('; ')}`;

    if (request.optionalHints) {
      userPrompt += `\n\nTEACHER HINTS: ${request.optionalHints}`;
    }

    userPrompt += `\n\nGenerate exactly ${request.questionCount} questions using the quiz_questions tool.`;

    try {
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey,
          'anthropic-version': '2023-06-01',
          'anthropic-dangerous-direct-browser-access': 'true',
        },
        body: JSON.stringify({
          model: 'claude-sonnet-4-20250514',
          max_tokens: 4096,
          system: systemPrompt,
          messages: [{ role: 'user', content: userPrompt }],
          tools: [{
            name: 'quiz_questions',
            description: 'Output quiz questions in structured format',
            input_schema: {
              type: 'object',
              properties: {
                questions: {
                  type: 'array',
                  items: {
                    type: 'object',
                    properties: {
                      question: { type: 'string' },
                      options: {
                        type: 'array',
                        items: { type: 'string' },
                        minItems: 4,
                        maxItems: 4
                      },
                      correctAnswerIndex: { type: 'integer', minimum: 0, maximum: 3 },
                      explanation: { type: 'string' }
                    },
                    required: ['question', 'options', 'correctAnswerIndex', 'explanation']
                  }
                }
              },
              required: ['questions']
            }
          }],
          tool_choice: { type: 'tool', name: 'quiz_questions' }
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new AIProviderError(
          this.getErrorMessage(response.status, errorText),
          this.getErrorCode(response.status),
          errorText
        );
      }

      const data = await response.json();

      // Extract from tool_use response
      const toolUse = data.content?.find((block: any) => block.type === 'tool_use');
      if (toolUse?.input?.questions) {
        return toolUse.input.questions;
      }

      // Fallback: try to extract from text if tool_use failed
      const textBlock = data.content?.find((block: any) => block.type === 'text');
      if (textBlock?.text) {
        try {
          const jsonMatch = textBlock.text.match(/\[[\s\S]*\]/);
          if (jsonMatch) {
            return JSON.parse(jsonMatch[0]);
          }
        } catch {
          // Fall through to empty array
        }
      }

      return [];
    } catch (error) {
      if (error instanceof AIProviderError) {
        throw error;
      }
      throw new AIProviderError(
        USER_ERROR_MESSAGES.NETWORK_ERROR,
        'NETWORK_ERROR',
        error
      );
    }
  }
```

Note: The method follows the existing Claude provider patterns (tool_use for structured output, same error handling).
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. ClaudeProvider fully implements AIProviderInterface
  </verify>
  <done>
- ClaudeProvider.generateGameQuestions exists and matches GeminiProvider behavior
- Uses Claude tool_use pattern for structured JSON output
- Millionaire has progressive difficulty
- Chase has consistent difficulty from BLOOM_DIFFICULTY_MAP
- Error handling follows existing patterns
  </done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - should complete with no errors
2. ClaudeProvider fully implements AIProviderInterface (no missing methods)
3. Prompt logic matches GeminiProvider (same difficulty rules)
4. Tool schema matches QuizQuestion interface
</verification>

<success_criteria>
- TypeScript compilation passes
- ClaudeProvider.generateGameQuestions exists
- Millionaire prompt includes progressive difficulty rules
- Chase prompt includes consistent difficulty from BLOOM_DIFFICULTY_MAP
- Uses tool_use pattern for reliable JSON output
- Error handling follows existing ClaudeProvider patterns
</success_criteria>

<output>
After completion, create `.planning/phases/22-ai-integration/22-03-SUMMARY.md`
</output>
