---
phase: 22-ai-integration
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - services/geminiService.ts
  - services/providers/geminiProvider.ts
autonomous: true

must_haves:
  truths:
    - "Millionaire questions have progressive difficulty (easy->medium->hard across question count)"
    - "Chase/Beat the Chaser questions have consistent difficulty matching teacher selection"
    - "Questions are generated ONLY from slide content (no external knowledge)"
    - "All questions have 4 plausible options with similar length"
  artifacts:
    - path: "services/geminiService.ts"
      provides: "generateGameQuestions function with game-specific prompts"
      contains: "generateGameQuestions"
      exports: ["generateGameQuestions"]
    - path: "services/providers/geminiProvider.ts"
      provides: "GeminiProvider.generateGameQuestions wrapper"
      contains: "generateGameQuestions"
  key_links:
    - from: "services/providers/geminiProvider.ts"
      to: "services/geminiService.ts"
      via: "function import"
      pattern: "generateGameQuestions as geminiGenerateGameQuestions"
    - from: "services/geminiService.ts"
      to: "services/aiProvider.ts"
      via: "type imports"
      pattern: "import.*GameQuestionRequest.*SlideContext.*BLOOM_DIFFICULTY_MAP"
---

<objective>
Implement game-specific question generation in the Gemini provider with Bloom's taxonomy difficulty progression.

Purpose: Gemini is the primary AI provider. This plan creates the actual AI prompt logic that generates Millionaire (progressive difficulty) and Chase (consistent difficulty) questions from slide content.

Output:
- generateGameQuestions function in geminiService.ts
- Millionaire prompt with explicit difficulty progression per question
- Chase/Beat the Chaser prompt with consistent difficulty level
- GeminiProvider wrapper method
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/22-ai-integration/22-CONTEXT.md
@.planning/phases/22-ai-integration/22-RESEARCH.md
@.planning/phases/22-ai-integration/22-01-SUMMARY.md
@services/geminiService.ts
@services/providers/geminiProvider.ts
@services/aiProvider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement generateGameQuestions in geminiService.ts</name>
  <files>services/geminiService.ts</files>
  <action>
1. Add imports at top (after existing imports from aiProvider):
```typescript
import { GameQuestionRequest, SlideContext, BLOOM_DIFFICULTY_MAP } from './aiProvider';
```

2. Add helper function for Millionaire progression rules (before generateGameQuestions):
```typescript
function getMillionaireProgressionRules(count: 3 | 5 | 10): string {
  if (count === 3) {
    return `
Question 1: EASY (Remember/Understand) - "What is...", "Name the..."
Question 2: MEDIUM (Apply/Analyze) - "How would...", "What would happen..."
Question 3: HARD (Evaluate/Create) - "Why does...", "What is the best..."`;
  }
  if (count === 5) {
    return `
Questions 1-2: EASY (Remember/Understand) - "What is...", "Name the..."
Questions 3-4: MEDIUM (Apply/Analyze) - "How would...", "What would happen..."
Question 5: HARD (Evaluate/Create) - "Why does...", "What is the best..."`;
  }
  // count === 10
  return `
Questions 1-3: EASY (Remember/Understand) - "What is...", "Name the..."
Questions 4-6: MEDIUM (Apply/Analyze) - "How would...", "What would happen..."
Questions 7-10: HARD (Evaluate/Create) - "Why does...", "What is the best..."`;
}
```

3. Add main generateGameQuestions function (after generatePhoneAFriendHint):
```typescript
export const generateGameQuestions = async (
  apiKey: string,
  request: GameQuestionRequest
): Promise<QuizQuestion[]> => {
  const ai = new GoogleGenAI({ apiKey });
  const model = "gemini-3-flash-preview";

  // Build system instruction based on game type
  let systemInstruction: string;

  if (request.gameType === 'millionaire') {
    systemInstruction = `
You are a quiz master creating "Who Wants to Be a Millionaire" style questions for Year 6 students (10-11 years old).

PROGRESSIVE DIFFICULTY RULES (Bloom's Taxonomy):
${getMillionaireProgressionRules(request.questionCount as 3 | 5 | 10)}

DISTRACTOR RULES (CRITICAL):
- All 4 options must be similar in length and specificity
- Distractors must be plausible misconceptions a student might have
- Never include "All of the above" or "None of the above"
- Avoid using negatives in questions ("Which is NOT...")

CONTENT CONSTRAINT (CRITICAL):
- Generate questions ONLY from the provided lesson content
- Do NOT use external knowledge beyond what is in the slides
- If content is thin, focus on what IS there rather than inventing new facts

OUTPUT FORMAT:
Return a JSON array with exactly ${request.questionCount} questions.
`;
  } else {
    // Chase or Beat the Chaser - consistent difficulty
    const difficultyConfig = BLOOM_DIFFICULTY_MAP[request.difficulty];
    systemInstruction = `
You are a quiz master creating rapid-fire questions for "The Chase" style game for Year 6 students (10-11 years old).

DIFFICULTY: ${request.difficulty.toUpperCase()}
${difficultyConfig.description}
Question types: ${difficultyConfig.questionTypes}

ALL questions must be at ${request.difficulty} level. No progression - consistent difficulty throughout.

QUICK-FIRE RULES:
- Questions should be answerable in 5-10 seconds
- Single concept per question, no multi-part questions
- Avoid ambiguous wording
- Keep options short (1-5 words each when possible)

DISTRACTOR RULES:
- All 4 options must be plausible
- Distractors should reflect common misconceptions
- Similar length and specificity across all options

CONTENT CONSTRAINT (CRITICAL):
- Generate questions ONLY from the provided lesson content
- Do NOT use external knowledge beyond what is in the slides

OUTPUT FORMAT:
Return a JSON array with exactly ${request.questionCount} questions.
`;
  }

  // Build prompt with slide context
  let prompt = `
LESSON CONTENT (Generate questions from this material only):
Topic: ${request.slideContext.lessonTopic}

${request.slideContext.cumulativeContent}

Current slide focus: ${request.slideContext.currentSlideTitle}
Key points: ${request.slideContext.currentSlideContent.join('; ')}
`;

  // Add teacher hints if provided
  if (request.optionalHints) {
    prompt += `\n\nTEACHER HINTS: ${request.optionalHints}`;
  }

  prompt += '\n\nGenerate the quiz now.';

  try {
    const response = await ai.models.generateContent({
      model,
      contents: prompt,
      config: {
        systemInstruction,
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              question: { type: Type.STRING },
              options: { type: Type.ARRAY, items: { type: Type.STRING }, description: "Must be exactly 4 options" },
              correctAnswerIndex: { type: Type.INTEGER, description: "Index 0-3" },
              explanation: { type: Type.STRING }
            },
            required: ['question', 'options', 'correctAnswerIndex', 'explanation']
          }
        }
      }
    });

    return JSON.parse(response.text || "[]");
  } catch (error) {
    console.error("Game Question Gen Error", error);
    return [];
  }
};
```

Note: The function returns empty array on error - the caller (Plan 03) will handle retries.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Function is exported: Check geminiService.ts exports generateGameQuestions
  </verify>
  <done>
- generateGameQuestions function exists in geminiService.ts
- Millionaire uses progressive difficulty based on question count
- Chase/Beat the Chaser uses consistent difficulty from BLOOM_DIFFICULTY_MAP
- Function accepts SlideContext and optionalHints
- Function is exported for use by GeminiProvider
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire generateGameQuestions into GeminiProvider</name>
  <files>services/providers/geminiProvider.ts</files>
  <action>
1. Add import for new function (in the import block from geminiService):
```typescript
  generateGameQuestions as geminiGenerateGameQuestions,
```

2. Add import for new types (in the import block from aiProvider):
```typescript
import { AIProviderInterface, AIProviderError, USER_ERROR_MESSAGES, GenerationInput, GameQuestionRequest } from '../aiProvider';
```

3. Add new method to GeminiProvider class (after generateQuestionWithAnswer):
```typescript
  async generateGameQuestions(
    request: GameQuestionRequest
  ): Promise<QuizQuestion[]> {
    try {
      return await geminiGenerateGameQuestions(this.apiKey, request);
    } catch (error) {
      throw this.wrapError(error);
    }
  }
```
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. GeminiProvider now has generateGameQuestions method
  </verify>
  <done>
- GeminiProvider implements generateGameQuestions from AIProviderInterface
- Method wraps geminiGenerateGameQuestions with error handling
- All imports are correct
  </done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - should complete with no errors
2. GeminiProvider fully implements AIProviderInterface (no missing methods)
3. generateGameQuestions is callable with GameQuestionRequest
4. Existing generateImpromptuQuiz still works (not removed)
</verification>

<success_criteria>
- TypeScript compilation passes
- GeminiProvider.generateGameQuestions exists and is callable
- Millionaire prompt includes progressive difficulty rules
- Chase prompt includes consistent difficulty from BLOOM_DIFFICULTY_MAP
- Prompts include content constraint to prevent hallucination
- Existing functionality unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/22-ai-integration/22-02-SUMMARY.md`
</output>
