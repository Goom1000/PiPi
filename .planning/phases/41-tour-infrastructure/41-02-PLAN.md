---
phase: 41-tour-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["41-01"]
files_modified:
  - hooks/useTourState.ts
  - types.ts
autonomous: true

must_haves:
  truths:
    - "Completed tours don't replay on next visit"
    - "Tour completion state persists across browser refresh"
    - "User can reset individual tour completion for re-watching"
    - "Multiple tours tracked independently (landing, editor, presentation)"
  artifacts:
    - path: "hooks/useTourState.ts"
      provides: "Tour state persistence hook"
      exports: ["useTourState", "TourId"]
    - path: "types.ts"
      provides: "TourState interface"
      contains: "TourState"
  key_links:
    - from: "hooks/useTourState.ts"
      to: "localStorage"
      via: "TOUR_STORAGE_KEY constant"
      pattern: "localStorage\\.(get|set)Item.*pipi-tour-state"
---

<objective>
Create useTourState hook for localStorage persistence of tour completion status.

Purpose: Enable the "completed tours don't replay" requirement (TOUR-03) by persisting which tours users have completed. Following the established useSettings.ts pattern for localStorage hooks.

Output: useTourState hook that tracks completion status for landing, editor, and presentation tours, with ability to mark complete and reset individual tours.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/41-tour-infrastructure/41-01-SUMMARY.md
@hooks/useSettings.ts
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TourState types to types.ts</name>
  <files>types.ts</files>
  <action>
Add TourState interface and TourId type to types.ts.

Add at end of file (after other interfaces):

```typescript
// --- Tour State ---

/** Valid tour identifiers - one per screen */
export type TourId = 'landing' | 'editor' | 'presentation';

/** Tour completion state persisted to localStorage */
export interface TourState {
  /** Tour IDs that user has completed */
  completedTours: TourId[];
  /** Timestamp when tour was last dismissed (for "remind me later" if needed) */
  lastDismissed: Partial<Record<TourId, number>>;
}

/** Default tour state for new users */
export const DEFAULT_TOUR_STATE: TourState = {
  completedTours: [],
  lastDismissed: {},
};
```

TourId is a union type to enable type-safe tour identification. Only the three screen-specific tours are allowed.
  </action>
  <verify>
Run `npm run typecheck` - no TypeScript errors.
Verify types are exported from types.ts.
  </verify>
  <done>TourState, TourId, and DEFAULT_TOUR_STATE exported from types.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Create useTourState hook</name>
  <files>hooks/useTourState.ts</files>
  <action>
Create `hooks/useTourState.ts` following the useSettings.ts pattern.

Requirements:
1. **Storage key:** `pipi-tour-state` (matches existing pipi- prefix convention)
2. **Validation:** isValidTourState function to guard against corrupted data
3. **Lazy init:** useState with function to read from localStorage on mount
4. **Persist:** useEffect to save to localStorage on state change
5. **API:**
   - `isCompleted(tourId: TourId): boolean` - check if tour is done
   - `markCompleted(tourId: TourId): void` - mark tour as complete
   - `resetTour(tourId: TourId): void` - allow re-watching a tour
   - `resetAllTours(): void` - reset everything (for testing/support)

Implementation pattern from RESEARCH.md:
```typescript
import { useState, useEffect, useCallback } from 'react';
import { TourState, TourId, DEFAULT_TOUR_STATE } from '../types';

const TOUR_STORAGE_KEY = 'pipi-tour-state';

// Validation guard
function isValidTourState(data: unknown): data is TourState {
  if (typeof data !== 'object' || data === null) return false;
  const obj = data as Record<string, unknown>;
  if (!Array.isArray(obj.completedTours)) return false;
  if (typeof obj.lastDismissed !== 'object') return false;
  return true;
}

// Read from storage with validation
function readTourState(): TourState {
  if (typeof window === 'undefined') return DEFAULT_TOUR_STATE;
  try {
    const stored = window.localStorage.getItem(TOUR_STORAGE_KEY);
    if (stored) {
      const parsed = JSON.parse(stored);
      if (isValidTourState(parsed)) {
        return { ...DEFAULT_TOUR_STATE, ...parsed };
      }
    }
  } catch (e) {
    console.warn('Failed to parse tour state from localStorage:', e);
  }
  return DEFAULT_TOUR_STATE;
}

export function useTourState() {
  const [state, setState] = useState<TourState>(readTourState);

  // Persist on change
  useEffect(() => {
    try {
      window.localStorage.setItem(TOUR_STORAGE_KEY, JSON.stringify(state));
    } catch (e) {
      console.warn('Failed to save tour state to localStorage:', e);
    }
  }, [state]);

  const isCompleted = useCallback((tourId: TourId) => {
    return state.completedTours.includes(tourId);
  }, [state.completedTours]);

  const markCompleted = useCallback((tourId: TourId) => {
    setState(prev => ({
      ...prev,
      completedTours: [...new Set([...prev.completedTours, tourId])],
    }));
  }, []);

  const resetTour = useCallback((tourId: TourId) => {
    setState(prev => ({
      ...prev,
      completedTours: prev.completedTours.filter(id => id !== tourId),
    }));
  }, []);

  const resetAllTours = useCallback(() => {
    setState(DEFAULT_TOUR_STATE);
  }, []);

  return { isCompleted, markCompleted, resetTour, resetAllTours };
}
```

Note: Using Set spread to prevent duplicate entries in completedTours.
  </action>
  <verify>
Run `npm run typecheck` - no TypeScript errors.
Manual test:
1. Import hook in App.tsx temporarily
2. Call markCompleted('landing')
3. Refresh page
4. Check isCompleted('landing') returns true
5. Check isCompleted('editor') returns false
6. Check localStorage contains pipi-tour-state with landing in completedTours
  </verify>
  <done>useTourState hook works with persistence, markCompleted, isCompleted, resetTour, resetAllTours.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run typecheck` passes
2. TourState interface exported from types.ts
3. useTourState hook exported from hooks/useTourState.ts
4. Hook correctly reads/writes localStorage with pipi-tour-state key
5. markCompleted persists across refresh
</verification>

<success_criteria>
- TourId type constrains to 'landing' | 'editor' | 'presentation'
- TourState interface defined with completedTours and lastDismissed
- useTourState hook provides:
  - isCompleted(tourId) - boolean check (TOUR-03)
  - markCompleted(tourId) - persist completion (TOUR-03)
  - resetTour(tourId) - allow re-watching
  - resetAllTours() - full reset for testing
- State persists across browser refresh (TOUR-03)
- Corrupted localStorage data handled gracefully with fallback to defaults
</success_criteria>

<output>
After completion, create `.planning/phases/41-tour-infrastructure/41-02-SUMMARY.md`
</output>
