---
phase: 28-caching-backward-compatibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - types.ts
  - services/loadService.ts
  - components/PresentationView.tsx
  - App.tsx
autonomous: true

must_haves:
  truths:
    - "Switching to a previously generated verbosity level is instant (no loading)"
    - "Refreshing browser preserves verbosity cache"
    - "Verbosity selection persists when navigating between slides"
    - "Editing slide content clears cached scripts for that slide"
    - "Loading old .cue files without verbosity data works without errors"
  artifacts:
    - path: "types.ts"
      provides: "Slide.verbosityCache optional property, CURRENT_FILE_VERSION = 2"
      contains: "verbosityCache.*concise.*detailed|CURRENT_FILE_VERSION = 2"
    - path: "services/loadService.ts"
      provides: "v1->v2 migration case (no-op)"
      contains: "fromVersion === 1"
    - path: "components/PresentationView.tsx"
      provides: "Cache-aware verbosity handler, navigation persistence"
      contains: "verbosityCache|onUpdateSlide"
    - path: "App.tsx"
      provides: "handleUpdateSlide passed to PresentationView, cache invalidation"
      contains: "onUpdateSlide.*handleUpdateSlide|verbosityCache.*undefined"
  key_links:
    - from: "components/PresentationView.tsx"
      to: "App.tsx handleUpdateSlide"
      via: "onUpdateSlide prop"
      pattern: "onUpdateSlide\\(currentSlide\\.id"
    - from: "handleVerbosityChange"
      to: "slide.verbosityCache"
      via: "cache lookup and update"
      pattern: "currentSlide\\.verbosityCache\\?\\."
---

<objective>
Add per-slide verbosity caching so teachers can switch between previously generated levels instantly, with cache persistence across browser refresh and file save/load.

Purpose: VERB-09 through VERB-12 - instant switching, refresh persistence, backward compatibility
Output: Working verbosity cache with file format support
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-caching-backward-compatibility/28-CONTEXT.md
@.planning/phases/28-caching-backward-compatibility/28-RESEARCH.md
@types.ts
@services/loadService.ts
@components/PresentationView.tsx
@App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Type Layer - Slide Interface and File Version</name>
  <files>types.ts, services/loadService.ts</files>
  <action>
Extend Slide interface and bump file version:

1. In `types.ts`, add optional verbosityCache to Slide interface (after hasQuestionFlag):
```typescript
// Verbosity cache for on-demand regenerated scripts
// Standard is speakerNotes; only cache concise/detailed
verbosityCache?: {
  concise?: string;
  detailed?: string;
};
```

2. In `types.ts`, change `CURRENT_FILE_VERSION = 1` to `CURRENT_FILE_VERSION = 2`

3. In `services/loadService.ts`, update migrateFile function to document v1->v2:
```typescript
if (fromVersion < CURRENT_FILE_VERSION) {
  console.log(`Migrating file from version ${fromVersion} to ${CURRENT_FILE_VERSION}`);
  // v1 -> v2: Added verbosityCache to Slide interface
  // No action needed - optional field defaults to undefined
  if (fromVersion === 1) {
    // Slides without verbosityCache will have it as undefined
    // This is correct behavior - cache is populated on-demand
  }
}
```

Note: No actual migration logic needed since verbosityCache is optional. Old files load fine with undefined cache.
  </action>
  <verify>
- `npm run build` succeeds with no type errors
- Grep for "verbosityCache" in types.ts shows the new interface property
- Grep for "CURRENT_FILE_VERSION = 2" confirms version bump
  </verify>
  <done>
Slide interface includes optional verbosityCache with concise/detailed properties. File version is 2 with documented migration case.
  </done>
</task>

<task type="auto">
  <name>Task 2: State Layer - Caching, Navigation, and Invalidation</name>
  <files>components/PresentationView.tsx, App.tsx</files>
  <action>
Implement cache-aware verbosity with navigation persistence:

**1. App.tsx - Pass handleUpdateSlide to PresentationView:**

Add onUpdateSlide prop to PresentationView component:
```tsx
<PresentationView
  slides={slides}
  onExit={() => setAppState(AppState.EDITING)}
  studentNames={studentNames}
  studentData={studentGrades}
  initialSlideIndex={presentationStartIndex}
  provider={provider}
  onError={handleComponentError}
  onRequestAI={handleRequestAI}
  onUpdateSlide={handleUpdateSlide}  // NEW
/>
```

**2. App.tsx - Cache invalidation in handleUpdateSlide:**

Modify handleUpdateSlide to clear verbosityCache when content/title changes:
```typescript
const handleUpdateSlide = useCallback((id: string, updates: Partial<Slide>) => {
  setSlides(prev => prev.map(s => {
    if (s.id !== id) return s;

    // Detect if content changed (invalidates verbosity cache)
    const contentChanged = updates.content !== undefined || updates.title !== undefined;

    // Special case: if only updating verbosityCache, preserve it
    const isOnlyCacheUpdate = Object.keys(updates).length === 1 && updates.verbosityCache !== undefined;

    return {
      ...s,
      ...updates,
      // Clear cache if content changed, unless this IS a cache update
      verbosityCache: contentChanged && !isOnlyCacheUpdate
        ? undefined
        : (updates.verbosityCache ?? s.verbosityCache),
    };
  }));
}, []);
```

**3. PresentationView.tsx - Add onUpdateSlide prop:**

Update interface:
```typescript
interface PresentationViewProps {
  slides: Slide[];
  onExit: () => void;
  studentNames: string[];
  studentData: StudentWithGrade[];
  initialSlideIndex?: number;
  provider: AIProviderInterface | null;
  onError: (title: string, message: string) => void;
  onRequestAI: (featureName: string) => void;
  onUpdateSlide: (id: string, updates: Partial<Slide>) => void;  // NEW
}
```

Update destructuring:
```typescript
const PresentationView: React.FC<PresentationViewProps> = ({
  slides, onExit, studentNames, studentData, initialSlideIndex = 0,
  provider, onError, onRequestAI, onUpdateSlide  // ADD
}) => {
```

**4. PresentationView.tsx - Cache-aware handleVerbosityChange:**

Replace existing handleVerbosityChange with:
```typescript
const handleVerbosityChange = async (newLevel: VerbosityLevel) => {
  if (newLevel === verbosityLevel) return;
  setVerbosityLevel(newLevel);

  // Standard uses speakerNotes directly - no cache needed
  if (newLevel === 'standard') {
    setRegeneratedScript(null);
    return;
  }

  // Check cache for instant switch
  const cached = currentSlide.verbosityCache?.[newLevel];
  if (cached) {
    setRegeneratedScript(cached);
    return;  // Instant switch from cache
  }

  // No cache - need to regenerate
  if (!provider) {
    // No AI provider - can't regenerate, stay at standard
    setVerbosityLevel('standard');
    setRegeneratedScript(null);
    return;
  }

  setIsRegenerating(true);

  try {
    const newScript = await provider.regenerateTeleprompter(currentSlide, newLevel);
    setRegeneratedScript(newScript);

    // Persist to slide cache (triggers auto-save)
    onUpdateSlide(currentSlide.id, {
      verbosityCache: {
        ...currentSlide.verbosityCache,
        [newLevel]: newScript,
      },
    });
  } catch (error) {
    console.error('Failed to regenerate teleprompter:', error);
    setVerbosityLevel('standard');
    setRegeneratedScript(null);
    if (error instanceof AIProviderError) {
      onError('Teleprompter Regeneration Failed', error.userMessage);
    } else {
      onError('Error', 'Could not regenerate teleprompter. Please try again.');
    }
  } finally {
    setIsRegenerating(false);
  }
};
```

**5. PresentationView.tsx - Maintain verbosity on slide navigation:**

Replace the existing useEffect that resets verbosity on slide change (lines ~254-257):
```typescript
// OLD - REMOVE:
// useEffect(() => {
//   setVerbosityLevel('standard');
//   setRegeneratedScript(null);
// }, [currentIndex]);

// NEW - Maintain verbosity, update display from cache:
useEffect(() => {
  if (verbosityLevel === 'standard') {
    setRegeneratedScript(null);
  } else {
    // Use cache if available, null otherwise (will need regeneration on click)
    const cached = currentSlide.verbosityCache?.[verbosityLevel];
    setRegeneratedScript(cached || null);
  }
}, [currentIndex, currentSlide.verbosityCache, verbosityLevel]);
```

Note: If cached is null/undefined, the UI will show speakerNotes but the button remains selected. User can click again to regenerate (will show loading then populate cache).
  </action>
  <verify>
Test sequence:
1. `npm run build` succeeds
2. Start dev server, open presentation
3. Click "Detailed" - should show loading then content
4. Click "Standard" - instant switch to speakerNotes
5. Click "Detailed" - instant switch (no loading, uses cache)
6. Navigate to next slide - verbosity stays "Detailed" (not reset to Standard)
7. Navigate back - cached Detailed shows instantly
8. Refresh browser - open same presentation, navigate to slide with cache, click Detailed - instant (cache persisted)
9. Edit slide content in editing mode - regenerate Detailed - should regenerate (cache was cleared)
  </verify>
  <done>
Verbosity changes check cache before regenerating. Cache updates persist to slide state via onUpdateSlide. Verbosity selection maintained during navigation. Cache invalidated when content/title edited.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **VERB-09 (Instant switch-back):**
   - Generate Detailed for slide 1
   - Switch to Standard
   - Switch back to Detailed - no loading spinner, instant content

2. **VERB-10 (Refresh persistence):**
   - Generate Detailed for slide 1
   - Refresh browser
   - Open same presentation
   - Navigate to slide 1, click Detailed - instant (from persisted cache)

3. **VERB-11 (Backward compatibility):**
   - Open an existing .cue file saved before this update
   - Should load normally, default to Standard
   - Can generate Concise/Detailed and cache works

4. **VERB-12 (File format support):**
   - Generate Detailed on a slide
   - Save presentation
   - Reload the file
   - Detailed should be instant (cache saved in file)

5. **Edge cases:**
   - Edit slide content -> cache cleared -> regeneration required
   - Navigate between slides -> verbosity selection maintained
   - No AI provider -> concise/detailed buttons remain disabled (existing behavior)
</verification>

<success_criteria>
1. Switching to previously generated verbosity level shows no loading indicator
2. Browser refresh preserves all cached verbosity scripts
3. Old .cue/.pipi files load without errors, default to Standard
4. Saved files include verbosity cache, restored on load
5. Editing slide content invalidates its verbosity cache
6. Verbosity selection persists during slide navigation
</success_criteria>

<output>
After completion, create `.planning/phases/28-caching-backward-compatibility/28-01-SUMMARY.md`
</output>
