---
phase: 27-verbosity-ui-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/geminiService.ts
  - services/aiProvider.ts
  - services/providers/geminiProvider.ts
  - services/providers/claudeProvider.ts
autonomous: true

must_haves:
  truths:
    - "AI can regenerate teleprompter scripts at different verbosity levels"
    - "Concise verbosity produces minimal 2-3 phrase guidance per segment"
    - "Detailed verbosity produces full script-like content with transitions"
    - "Standard verbosity remains unchanged (existing behavior)"
  artifacts:
    - path: "services/geminiService.ts"
      provides: "regenerateTeleprompter function and verbosity-specific rules"
      exports: ["regenerateTeleprompter", "TELEPROMPTER_RULES_CONCISE", "TELEPROMPTER_RULES_DETAILED"]
    - path: "services/aiProvider.ts"
      provides: "VerbosityLevel type and interface method"
      exports: ["VerbosityLevel", "AIProviderInterface.regenerateTeleprompter"]
    - path: "services/providers/geminiProvider.ts"
      provides: "Gemini implementation of regenerateTeleprompter"
    - path: "services/providers/claudeProvider.ts"
      provides: "Claude implementation of regenerateTeleprompter"
  key_links:
    - from: "services/providers/geminiProvider.ts"
      to: "services/geminiService.ts"
      via: "import and call regenerateTeleprompter"
      pattern: "geminiRegenerateTeleprompter"
    - from: "services/providers/claudeProvider.ts"
      to: "services/aiProvider.ts"
      via: "implements AIProviderInterface"
      pattern: "regenerateTeleprompter.*VerbosityLevel"
---

<objective>
Add verbosity-aware teleprompter regeneration to the AI service layer.

Purpose: Enable AI providers to regenerate teleprompter scripts at three verbosity levels (concise, standard, detailed) so the UI can request different script styles on-demand.

Output: New `regenerateTeleprompter` method on AIProviderInterface with implementations for Gemini and Claude providers, plus verbosity-specific system instructions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-verbosity-ui-generation/27-RESEARCH.md
@services/geminiService.ts
@services/aiProvider.ts
@services/providers/geminiProvider.ts
@services/providers/claudeProvider.ts
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add verbosity rules and regeneration function to geminiService.ts</name>
  <files>services/geminiService.ts</files>
  <action>
Add three new constants for verbosity-specific teleprompter rules:

1. `TELEPROMPTER_RULES_CONCISE`:
```typescript
const TELEPROMPTER_RULES_CONCISE = `
CONCISE SPEAKER NOTES (BULLET-POINT STYLE):
The teacher wants MINIMAL guidance - just key prompts to jog memory.

RULES:
- Output 2-3 short phrases per segment (not full sentences)
- Use comma-separated points, not prose
- Focus on: key term, quick example, one action
- NO transitions, NO elaborate explanations

FORMATTING:
Use "ðŸ‘‰" as delimiter. Segments = Bullets + 1.
- Segment 0: One-liner setup (5-8 words)
- Segment N: 2-3 comma-separated prompts

EXAMPLE OUTPUT:
"Quick review of fractions ðŸ‘‰ denominator = parts total, numerator = parts we have ðŸ‘‰ example: 3/4 pizza, draw on board ðŸ‘‰ check: ask which is bigger, 1/2 or 1/4"
`;
```

2. `TELEPROMPTER_RULES_DETAILED`:
```typescript
const TELEPROMPTER_RULES_DETAILED = `
DETAILED SPEAKER NOTES (SCRIPT STYLE):
The teacher wants a FULL SCRIPT they can read verbatim for confident delivery.

RULES:
- Write complete sentences in conversational tone
- Include transition phrases: "Now let's look at...", "As you can see...", "So what does this mean?"
- Add prompts for student interaction: "[PAUSE for questions]", "[Wait for responses]"
- Include teacher actions: "[Point to diagram]", "[Write on board]"
- Each segment should be 3-5 sentences

FORMATTING:
Use "ðŸ‘‰" as delimiter. Segments = Bullets + 1.
- Segment 0: Full introduction with hook and preview
- Segment N: Complete teaching script with examples and checks

EXAMPLE OUTPUT:
"Alright everyone, today we're going to explore something really interesting - fractions! [PAUSE] Has anyone ever shared a pizza with friends? That's exactly what fractions help us understand. ðŸ‘‰ So when we look at this first point, the denominator - that's the number on the bottom - tells us how many equal parts we've divided something into. Think of it like cutting a cake into slices. If we cut it into 4 pieces, our denominator is 4. [Point to example on board] Does that make sense so far? ðŸ‘‰ ..."
`;
```

3. Add the `regenerateTeleprompter` function:
```typescript
export type VerbosityLevel = 'concise' | 'standard' | 'detailed';

export const regenerateTeleprompter = async (
    apiKey: string,
    slide: Slide,
    verbosity: VerbosityLevel
): Promise<string> => {
    const ai = new GoogleGenAI({ apiKey });
    const model = "gemini-3-flash-preview";

    const rules = verbosity === 'concise'
        ? TELEPROMPTER_RULES_CONCISE
        : verbosity === 'detailed'
        ? TELEPROMPTER_RULES_DETAILED
        : TELEPROMPTER_RULES; // standard - existing behavior

    const systemInstruction = `
You are regenerating teleprompter notes for an existing slide.
The slide has ${slide.content.length} bullet points.

${rules}

CRITICAL: Output ONLY the speaker notes text. No JSON, no markdown code blocks, no explanations.
`;

    const prompt = `
Slide Title: ${slide.title}
Slide Content:
${slide.content.map((b, i) => `${i + 1}. ${b}`).join('\n')}

Generate speaker notes in ${verbosity} style.
`;

    try {
        const response = await ai.models.generateContent({
            model,
            contents: prompt,
            config: {
                systemInstruction,
                responseMimeType: "text/plain"
            }
        });

        return response.text?.trim() || "";
    } catch (error) {
        console.error("Teleprompter Regeneration Error:", error);
        throw new AIProviderError(USER_ERROR_MESSAGES.NETWORK_ERROR, 'NETWORK_ERROR', error);
    }
};
```

Export the new type and function at the module level.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
Check that exports are present: `grep -n "export.*regenerateTeleprompter\|export type VerbosityLevel" services/geminiService.ts`
  </verify>
  <done>
geminiService.ts exports `VerbosityLevel` type, `TELEPROMPTER_RULES_CONCISE`, `TELEPROMPTER_RULES_DETAILED` constants (internal), and `regenerateTeleprompter` function that accepts slide and verbosity level.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update AIProviderInterface and implement in both providers</name>
  <files>services/aiProvider.ts, services/providers/geminiProvider.ts, services/providers/claudeProvider.ts</files>
  <action>
**In services/aiProvider.ts:**

1. Import VerbosityLevel from geminiService:
```typescript
import { QuizQuestion, QuestionWithAnswer, VerbosityLevel } from './geminiService';
```

2. Re-export VerbosityLevel for consumers:
```typescript
export { VerbosityLevel } from './geminiService';
```

3. Add to AIProviderInterface (after generateGameQuestions):
```typescript
// Regenerate teleprompter script at specified verbosity level
regenerateTeleprompter(
    slide: Slide,
    verbosity: VerbosityLevel
): Promise<string>;
```

**In services/providers/geminiProvider.ts:**

1. Import the new function:
```typescript
import {
  // ... existing imports ...
  regenerateTeleprompter as geminiRegenerateTeleprompter,
} from '../geminiService';
```

2. Import VerbosityLevel from aiProvider:
```typescript
import { AIProviderInterface, ..., VerbosityLevel } from '../aiProvider';
```
Note: VerbosityLevel is re-exported from aiProvider, so import from there for consistency.

3. Add implementation to GeminiProvider class:
```typescript
async regenerateTeleprompter(slide: Slide, verbosity: VerbosityLevel): Promise<string> {
    try {
        return await geminiRegenerateTeleprompter(this.apiKey, slide, verbosity);
    } catch (error) {
        throw this.wrapError(error);
    }
}
```

**In services/providers/claudeProvider.ts:**

1. Import VerbosityLevel (it's re-exported from aiProvider, which is already imported).

2. Add TELEPROMPTER_RULES_CONCISE and TELEPROMPTER_RULES_DETAILED constants (copy from geminiService, but replace ðŸ‘‰ with the unicode escape pattern used in claudeProvider for consistency with existing TELEPROMPTER_RULES).

3. Add implementation to ClaudeProvider class:
```typescript
async regenerateTeleprompter(slide: Slide, verbosity: VerbosityLevel): Promise<string> {
    const rules = verbosity === 'concise'
        ? TELEPROMPTER_RULES_CONCISE
        : verbosity === 'detailed'
        ? TELEPROMPTER_RULES_DETAILED
        : TELEPROMPTER_RULES; // standard

    const systemPrompt = `
You are regenerating teleprompter notes for an existing slide.
The slide has ${slide.content.length} bullet points.

${rules}

CRITICAL: Output ONLY the speaker notes text as plain text. No JSON, no markdown code blocks, no explanations.
`;

    const messages: ClaudeMessage[] = [{
        role: 'user',
        content: `Slide Title: ${slide.title}\nSlide Content:\n${slide.content.map((b, i) => `${i + 1}. ${b}`).join('\n')}\n\nGenerate speaker notes in ${verbosity} style.`
    }];

    const response = await callClaude(this.apiKey, messages, systemPrompt, 2048);
    return response.trim();
}
```

Note: The claudeProvider already has the TELEPROMPTER_RULES constant defined locally with the unicode escape pattern. Add the concise and detailed variants following the same pattern (using `.replace(/pointing_right/g, '\u{1F449}')` for the ðŸ‘‰ emoji).
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Check interface has new method: `grep -n "regenerateTeleprompter" services/aiProvider.ts`
Check both providers implement it: `grep -n "regenerateTeleprompter" services/providers/geminiProvider.ts services/providers/claudeProvider.ts`
  </verify>
  <done>
AIProviderInterface includes `regenerateTeleprompter(slide, verbosity)` method. GeminiProvider delegates to geminiService. ClaudeProvider implements with Claude API call. Both handle errors consistently with existing patterns.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. All three verbosity rule constants exist in geminiService.ts
3. VerbosityLevel type is exported from aiProvider.ts
4. Both providers implement regenerateTeleprompter method
5. No breaking changes to existing API (existing functions unchanged)
</verification>

<success_criteria>
- VerbosityLevel type ('concise' | 'standard' | 'detailed') exported from aiProvider
- regenerateTeleprompter method added to AIProviderInterface
- GeminiProvider.regenerateTeleprompter calls geminiService function
- ClaudeProvider.regenerateTeleprompter makes Claude API call with verbosity-specific rules
- All existing tests/functionality unchanged (Standard = existing TELEPROMPTER_RULES)
</success_criteria>

<output>
After completion, create `.planning/phases/27-verbosity-ui-generation/27-01-SUMMARY.md`
</output>
