---
phase: 24-beat-the-chaser
plan: 04
type: execute
wave: 3
depends_on: ["24-02", "24-03"]
files_modified:
  - components/games/BeatTheChaserGame.tsx
  - components/games/GameContainer.tsx
  - components/games/beat-the-chaser/GameResult.tsx
autonomous: true

must_haves:
  truths:
    - "BeatTheChaserGame orchestrates setup -> cash-builder -> timed-battle -> game-over flow"
    - "Setup modal triggers question generation before game starts"
    - "State updates broadcast to student view via onStateUpdate callback"
    - "GameContainer passes onBeatTheChaserStateUpdate handler to BeatTheChaserGame"
  artifacts:
    - path: "components/games/BeatTheChaserGame.tsx"
      provides: "Main game orchestrator"
      exports: ["default"]
      min_lines: 150
    - path: "components/games/beat-the-chaser/GameResult.tsx"
      provides: "Win/loss outcome screen"
      exports: ["default"]
  key_links:
    - from: "BeatTheChaserGame.tsx"
      to: "CashBuilderPhase.tsx"
      via: "import and render"
      pattern: "CashBuilderPhase"
    - from: "BeatTheChaserGame.tsx"
      to: "TimedBattlePhase.tsx"
      via: "import and render"
      pattern: "TimedBattlePhase"
    - from: "GameContainer.tsx"
      to: "BeatTheChaserGame.tsx"
      via: "onBeatTheChaserStateUpdate prop"
      pattern: "onBeatTheChaserStateUpdate"
---

<objective>
Create BeatTheChaserGame orchestrator and integrate with GameContainer.

Purpose: Orchestrate the complete game flow from setup through game over, managing phase transitions and state updates. Similar pattern to TheChaseGame but simpler (3 phases vs 4).

Output: Working BeatTheChaserGame that replaces the placeholder, with proper state broadcasting to student view.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/24-beat-the-chaser/24-CONTEXT.md
@components/games/TheChaseGame.tsx
@components/games/GameContainer.tsx
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GameResult component</name>
  <files>components/games/beat-the-chaser/GameResult.tsx</files>
  <action>
Create GameResult component for displaying win/loss outcome:

```typescript
import React from 'react';

interface GameResultProps {
  winner: 'contestant' | 'chaser';
  contestantFinalTime: number;
  chaserFinalTime: number;
  onClose: () => void;
}

const GameResult: React.FC<GameResultProps> = ({
  winner,
  contestantFinalTime,
  chaserFinalTime,
  onClose
}) => {
  const contestantWon = winner === 'contestant';

  return (
    <div className={`w-full h-full flex flex-col items-center justify-center p-8 font-poppins text-white ${
      contestantWon
        ? 'bg-gradient-to-br from-green-900 via-slate-900 to-green-900'
        : 'bg-gradient-to-br from-red-900 via-slate-900 to-red-900'
    }`}>
      {/* Result Banner */}
      <div className="text-center mb-12">
        <h1 className={`text-7xl md:text-9xl font-black mb-4 ${
          contestantWon ? 'text-green-400' : 'text-red-400'
        }`}>
          {contestantWon ? 'VICTORY!' : 'DEFEATED!'}
        </h1>
        <p className="text-2xl md:text-3xl text-white">
          {contestantWon
            ? "You beat the chaser!"
            : "The chaser caught you!"
          }
        </p>
      </div>

      {/* Final Times */}
      <div className="flex gap-8 md:gap-16 mb-12">
        <div className={`text-center p-8 rounded-2xl ${
          contestantWon ? 'bg-blue-900/50 border-2 border-blue-500' : 'bg-slate-800/50'
        }`}>
          <div className={`text-6xl md:text-8xl font-bold ${
            contestantWon ? 'text-blue-400' : 'text-slate-400'
          } mb-2`}>
            {contestantFinalTime}s
          </div>
          <div className="text-slate-300 uppercase tracking-wider">Contestant</div>
        </div>

        <div className="flex items-center">
          <div className="text-4xl md:text-6xl font-bold text-slate-500">vs</div>
        </div>

        <div className={`text-center p-8 rounded-2xl ${
          !contestantWon ? 'bg-red-900/50 border-2 border-red-500' : 'bg-slate-800/50'
        }`}>
          <div className={`text-6xl md:text-8xl font-bold ${
            !contestantWon ? 'text-red-400' : 'text-slate-400'
          } mb-2`}>
            {chaserFinalTime}s
          </div>
          <div className="text-slate-300 uppercase tracking-wider">Chaser</div>
        </div>
      </div>

      {/* Explanation */}
      <p className="text-lg text-slate-400 mb-8 text-center max-w-lg">
        {contestantWon
          ? "The chaser's time ran out before yours. Well played!"
          : "Your time ran out before the chaser's. Better luck next time!"
        }
      </p>

      {/* Exit Button */}
      <button
        onClick={onClose}
        className="px-8 py-4 bg-white text-slate-900 font-bold rounded-xl hover:scale-105 transition-transform text-lg"
      >
        Back to Lesson
      </button>
    </div>
  );
};

export default GameResult;
```
  </action>
  <verify>TypeScript compiles: `cd "/Users/ricky/Documents/App_Projects/Education Apps/DEV - PiPi" && npx tsc --noEmit`</verify>
  <done>GameResult displays win/loss with final times for both players</done>
</task>

<task type="auto">
  <name>Task 2: Create BeatTheChaserGame orchestrator</name>
  <files>components/games/BeatTheChaserGame.tsx</files>
  <action>
Replace the placeholder BeatTheChaserGame with full orchestrator:

```typescript
import React, { useState, useCallback } from 'react';
import { BeatTheChaserState, BeatTheChaserPhase } from '../../types';
import SetupModal from './beat-the-chaser/SetupModal';
import CashBuilderPhase from './beat-the-chaser/CashBuilderPhase';
import TimedBattlePhase from './beat-the-chaser/TimedBattlePhase';
import GameResult from './beat-the-chaser/GameResult';
import {
  BeatTheChaserDifficulty,
  calculateChaserTime,
  CASH_BUILDER_QUESTIONS
} from './beat-the-chaser/beatTheChaserConfig';

interface BeatTheChaserGameProps {
  state: BeatTheChaserState;
  onClose: () => void;
  onStateUpdate?: (updates: Partial<BeatTheChaserState>) => void;
}

/**
 * Main orchestrator for Beat the Chaser game.
 * Manages phase transitions: Setup -> Cash Builder -> Timed Battle -> Game Over
 * Broadcasts state updates to student view via onStateUpdate callback.
 */
const BeatTheChaserGame: React.FC<BeatTheChaserGameProps> = ({
  state,
  onClose,
  onStateUpdate
}) => {
  // Local phase state (teacher-side management)
  const [localPhase, setLocalPhase] = useState<BeatTheChaserPhase>('setup');
  const [difficulty, setDifficulty] = useState<BeatTheChaserDifficulty>('medium');
  const [isAIControlled, setIsAIControlled] = useState(true);
  const [accumulatedTime, setAccumulatedTime] = useState(0);
  const [chaserTime, setChaserTime] = useState(0);
  const [winner, setWinner] = useState<'contestant' | 'chaser' | null>(null);
  const [finalContestantTime, setFinalContestantTime] = useState(0);
  const [finalChaserTime, setFinalChaserTime] = useState(0);

  // Update state and broadcast
  const updateState = useCallback((updates: Partial<BeatTheChaserState>) => {
    onStateUpdate?.(updates);
  }, [onStateUpdate]);

  // Setup complete -> Start Cash Builder
  const handleSetupComplete = useCallback((
    selectedDifficulty: BeatTheChaserDifficulty,
    aiControlled: boolean
  ) => {
    setDifficulty(selectedDifficulty);
    setIsAIControlled(aiControlled);
    setLocalPhase('cash-builder');

    updateState({
      phase: 'cash-builder',
      chaserDifficulty: selectedDifficulty,
      isAIControlled: aiControlled,
      accumulatedTime: 0,
      cashBuilderQuestionsAnswered: 0,
      cashBuilderCorrectAnswers: 0
    });
  }, [updateState]);

  // Cash Builder complete -> Start Timed Battle
  const handleCashBuilderComplete = useCallback((time: number) => {
    setAccumulatedTime(time);
    const calculatedChaserTime = calculateChaserTime(time, difficulty);
    setChaserTime(calculatedChaserTime);
    setLocalPhase('timed-battle');

    updateState({
      phase: 'timed-battle',
      accumulatedTime: time,
      contestantTime: time,
      chaserTime: calculatedChaserTime,
      activePlayer: 'contestant'
    });
  }, [difficulty, updateState]);

  // Timed Battle complete -> Game Over
  const handleTimedBattleComplete = useCallback((gameWinner: 'contestant' | 'chaser') => {
    setWinner(gameWinner);
    setLocalPhase('game-over');

    updateState({
      phase: 'game-over',
      winner: gameWinner
    });
  }, [updateState]);

  // Handle timed battle state updates (for timer syncing)
  const handleTimedBattleStateUpdate = useCallback((battleState: {
    contestantTime: number;
    chaserTime: number;
    activePlayer: 'contestant' | 'chaser';
  }) => {
    setFinalContestantTime(battleState.contestantTime);
    setFinalChaserTime(battleState.chaserTime);

    updateState({
      contestantTime: battleState.contestantTime,
      chaserTime: battleState.chaserTime,
      activePlayer: battleState.activePlayer
    });
  }, [updateState]);

  // Render based on phase
  switch (localPhase) {
    case 'setup':
      return (
        <SetupModal
          onStart={handleSetupComplete}
          onCancel={onClose}
        />
      );

    case 'cash-builder':
      // Use first CASH_BUILDER_QUESTIONS for Cash Builder
      const cashBuilderQuestions = state.questions.slice(0, CASH_BUILDER_QUESTIONS);
      return (
        <CashBuilderPhase
          questions={cashBuilderQuestions}
          onComplete={handleCashBuilderComplete}
          onExit={onClose}
        />
      );

    case 'timed-battle':
      // Use remaining questions for Timed Battle
      const battleQuestions = state.questions.slice(CASH_BUILDER_QUESTIONS);
      return (
        <TimedBattlePhase
          contestantStartTime={accumulatedTime}
          chaserStartTime={chaserTime}
          difficulty={difficulty}
          isAIControlled={isAIControlled}
          questions={battleQuestions}
          onComplete={handleTimedBattleComplete}
          onExit={onClose}
          onStateUpdate={handleTimedBattleStateUpdate}
        />
      );

    case 'game-over':
      return (
        <GameResult
          winner={winner!}
          contestantFinalTime={finalContestantTime}
          chaserFinalTime={finalChaserTime}
          onClose={onClose}
        />
      );

    default:
      // Fallback
      return (
        <div className="w-full h-full bg-slate-900 flex items-center justify-center">
          <div className="text-center">
            <p className="text-3xl font-bold text-red-500 mb-4">Unknown game phase</p>
            <button
              onClick={onClose}
              className="px-6 py-3 bg-white text-slate-900 font-bold rounded-xl hover:scale-105 transition-transform"
            >
              Exit Game
            </button>
          </div>
        </div>
      );
  }
};

export default BeatTheChaserGame;
```

Key patterns from TheChaseGame:
- Local phase state management
- State broadcasting via onStateUpdate callback
- Phase-specific rendering via switch statement
- Question slicing (first 10 for Cash Builder, rest for Battle)
  </action>
  <verify>TypeScript compiles: `cd "/Users/ricky/Documents/App_Projects/Education Apps/DEV - PiPi" && npx tsc --noEmit`</verify>
  <done>BeatTheChaserGame orchestrates all phases and broadcasts state updates</done>
</task>

<task type="auto">
  <name>Task 3: Update GameContainer with state handler</name>
  <files>components/games/GameContainer.tsx</files>
  <action>
Update GameContainer to pass onBeatTheChaserStateUpdate handler to BeatTheChaserGame:

1. Add new prop to GameContainerProps interface:
   ```typescript
   // Beat the Chaser-specific handler
   onBeatTheChaserStateUpdate?: (updates: Partial<import('../../types').BeatTheChaserState>) => void;
   ```

2. Update the destructuring to include onBeatTheChaserStateUpdate

3. Update the 'beat-the-chaser' case to pass the handler:
   ```typescript
   case 'beat-the-chaser':
     return (
       <BeatTheChaserGame
         state={state}
         onClose={onClose}
         onStateUpdate={onBeatTheChaserStateUpdate}
       />
     );
   ```

This follows the same pattern used for TheChaseGame with onChaseStateUpdate.
  </action>
  <verify>TypeScript compiles: `cd "/Users/ricky/Documents/App_Projects/Education Apps/DEV - PiPi" && npx tsc --noEmit`</verify>
  <done>GameContainer passes state update handler to BeatTheChaserGame</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. BeatTheChaserGame replaces placeholder implementation
3. Setup -> Cash Builder -> Timed Battle -> Game Over flow works
4. GameContainer properly routes to BeatTheChaserGame with state handler
</verification>

<success_criteria>
- BeatTheChaserGame orchestrates complete game flow
- Setup modal triggers phase transition to cash-builder
- Cash Builder completion calculates chaser time and transitions to timed-battle
- Timed Battle completion determines winner and transitions to game-over
- State updates broadcast to student view via onStateUpdate
- GameContainer integrates onBeatTheChaserStateUpdate handler
</success_criteria>

<output>
After completion, create `.planning/phases/24-beat-the-chaser/24-04-SUMMARY.md`
</output>
