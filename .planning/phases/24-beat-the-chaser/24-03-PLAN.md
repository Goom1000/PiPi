---
phase: 24-beat-the-chaser
plan: 03
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - components/games/beat-the-chaser/DualTimerDisplay.tsx
  - components/games/beat-the-chaser/TimeBonusEffect.tsx
  - components/games/beat-the-chaser/TimedBattlePhase.tsx
autonomous: true

must_haves:
  truths:
    - "Dual timers display side-by-side with contestant on left, chaser on right"
    - "Active player's timer glows/pulses, inactive timer is dimmed"
    - "Only active player's timer counts down during their turn"
    - "Contestant earns +5s when chaser answers incorrectly"
    - "Timer hitting zero triggers instant loss"
  artifacts:
    - path: "components/games/beat-the-chaser/DualTimerDisplay.tsx"
      provides: "Side-by-side countdown timer display"
      exports: ["default"]
    - path: "components/games/beat-the-chaser/TimeBonusEffect.tsx"
      provides: "Floating +5s animation component"
      exports: ["default"]
    - path: "components/games/beat-the-chaser/TimedBattlePhase.tsx"
      provides: "Main timed battle phase with turn mechanics"
      exports: ["default"]
      min_lines: 150
  key_links:
    - from: "TimedBattlePhase.tsx"
      to: "hooks/useTimer.ts"
      via: "import hook"
      pattern: "useTimer"
    - from: "TimedBattlePhase.tsx"
      to: "hooks/useChaserAI.ts"
      via: "import hook"
      pattern: "useChaserAI"
---

<objective>
Create timed battle phase with dual independent timers and turn-based mechanics.

Purpose: The core gameplay of Beat the Chaser - contestant and chaser race against time with only the active player's timer running. Both players answer the same question sequentially. Catch-up mechanic: contestant earns +5s when chaser gets wrong answer during chaser's turn.

Output: DualTimerDisplay, TimeBonusEffect, and TimedBattlePhase components implementing the complete timed battle mechanics.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/24-beat-the-chaser/24-CONTEXT.md
@.planning/phases/24-beat-the-chaser/24-RESEARCH.md
@hooks/useTimer.ts
@hooks/useChaserAI.ts
@components/games/beat-the-chaser/beatTheChaserConfig.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DualTimerDisplay component</name>
  <files>components/games/beat-the-chaser/DualTimerDisplay.tsx</files>
  <action>
Create DualTimerDisplay component showing both timers side-by-side:

```typescript
import React from 'react';

interface DualTimerDisplayProps {
  contestantTime: number;
  chaserTime: number;
  activePlayer: 'contestant' | 'chaser';
}

const DualTimerDisplay: React.FC<DualTimerDisplayProps> = ({
  contestantTime,
  chaserTime,
  activePlayer
}) => {
  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const isUrgent = (time: number) => time <= 10;

  const getTimerClasses = (time: number, isActive: boolean, isContestant: boolean) => {
    const base = "flex-1 p-6 md:p-8 rounded-3xl transition-all duration-300";
    const bgColor = isContestant ? 'bg-blue-900/60' : 'bg-red-900/60';
    const urgent = isUrgent(time) ? 'animate-pulse' : '';
    const active = isActive
      ? 'ring-4 ring-yellow-400 scale-105 shadow-xl shadow-yellow-500/20'
      : 'opacity-50 scale-95';

    return `${base} ${bgColor} ${urgent} ${active}`;
  };

  return (
    <div className="flex gap-4 md:gap-6 w-full max-w-4xl mx-auto mb-6">
      {/* Contestant Timer - Left */}
      <div className={getTimerClasses(contestantTime, activePlayer === 'contestant', true)}>
        <div className="text-center">
          <div className="text-sm uppercase tracking-wider text-blue-300 mb-2">
            Contestant
          </div>
          <div className={`text-5xl md:text-7xl font-black ${
            isUrgent(contestantTime) ? 'text-red-500' : 'text-white'
          }`}>
            {formatTime(contestantTime)}
          </div>
          {activePlayer === 'contestant' && (
            <div className="mt-3 text-sm font-bold text-yellow-400 animate-bounce">
              YOUR TURN
            </div>
          )}
        </div>
      </div>

      {/* VS Divider */}
      <div className="flex items-center justify-center px-2">
        <div className="text-3xl md:text-4xl font-black text-slate-500">VS</div>
      </div>

      {/* Chaser Timer - Right */}
      <div className={getTimerClasses(chaserTime, activePlayer === 'chaser', false)}>
        <div className="text-center">
          <div className="text-sm uppercase tracking-wider text-red-300 mb-2">
            Chaser
          </div>
          <div className={`text-5xl md:text-7xl font-black ${
            isUrgent(chaserTime) ? 'text-red-500' : 'text-white'
          }`}>
            {formatTime(chaserTime)}
          </div>
          {activePlayer === 'chaser' && (
            <div className="mt-3 text-sm font-bold text-red-400 animate-bounce">
              CHASER'S TURN
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default DualTimerDisplay;
```

Visual specs:
- Contestant (blue) on left, Chaser (red) on right
- Active timer: ring glow, scale up, full opacity
- Inactive timer: dimmed (50% opacity), scale down
- Urgency: red text + pulse animation when <= 10s
- Turn indicator: bouncing label under active timer
  </action>
  <verify>TypeScript compiles: `cd "/Users/ricky/Documents/App_Projects/Education Apps/DEV - PiPi" && npx tsc --noEmit`</verify>
  <done>DualTimerDisplay shows side-by-side timers with active/inactive styling and urgency at 10s</done>
</task>

<task type="auto">
  <name>Task 2: Create TimeBonusEffect component</name>
  <files>components/games/beat-the-chaser/TimeBonusEffect.tsx</files>
  <action>
Create floating +5s animation component using CSS keyframes:

```typescript
import React, { useEffect, useState } from 'react';

interface TimeBonusEffectProps {
  show: boolean;
  amount: number;  // Typically 5
  onComplete?: () => void;
}

const TimeBonusEffect: React.FC<TimeBonusEffectProps> = ({
  show,
  amount,
  onComplete
}) => {
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    if (show) {
      setIsVisible(true);
      // Animation duration: 1200ms
      const timer = setTimeout(() => {
        setIsVisible(false);
        onComplete?.();
      }, 1200);
      return () => clearTimeout(timer);
    }
  }, [show, onComplete]);

  if (!isVisible) return null;

  return (
    <div className="fixed inset-0 pointer-events-none z-50 flex items-center justify-center">
      <div
        className="text-7xl md:text-9xl font-black text-green-400 drop-shadow-2xl"
        style={{
          animation: 'floatUp 1.2s ease-out forwards',
          textShadow: '0 0 40px rgba(74, 222, 128, 0.8)'
        }}
      >
        +{amount}s
      </div>

      {/* Inline keyframes - CSS-in-JS for portability */}
      <style>{`
        @keyframes floatUp {
          0% {
            opacity: 0;
            transform: translateY(20px) scale(0.8);
          }
          20% {
            opacity: 1;
            transform: translateY(-10px) scale(1.1);
          }
          100% {
            opacity: 0;
            transform: translateY(-80px) scale(1);
          }
        }
      `}</style>
    </div>
  );
};

export default TimeBonusEffect;
```

Animation specs:
- Starts small and transparent, scales up
- Floats upward while fading out
- 1200ms total duration
- Green color with glow effect
- Non-blocking (doesn't prevent interaction)
  </action>
  <verify>TypeScript compiles: `cd "/Users/ricky/Documents/App_Projects/Education Apps/DEV - PiPi" && npx tsc --noEmit`</verify>
  <done>TimeBonusEffect displays floating +5s animation with fade-up effect</done>
</task>

<task type="auto">
  <name>Task 3: Create TimedBattlePhase component</name>
  <files>components/games/beat-the-chaser/TimedBattlePhase.tsx</files>
  <action>
Create main TimedBattlePhase component with dual timer control and turn mechanics:

```typescript
import React, { useState, useEffect, useCallback } from 'react';
import { QuizQuestion } from '../../../services/geminiService';
import { useTimer } from '../../../hooks/useTimer';
import { useChaserAI } from '../../../hooks/useChaserAI';
import DualTimerDisplay from './DualTimerDisplay';
import TimeBonusEffect from './TimeBonusEffect';
import { TIME_BONUS_AMOUNT, CHASER_THINKING_DELAY, BeatTheChaserDifficulty } from './beatTheChaserConfig';

interface TimedBattlePhaseProps {
  contestantStartTime: number;
  chaserStartTime: number;
  difficulty: BeatTheChaserDifficulty;
  isAIControlled: boolean;
  questions: QuizQuestion[];
  onComplete: (winner: 'contestant' | 'chaser') => void;
  onExit: () => void;
  onStateUpdate?: (state: {
    contestantTime: number;
    chaserTime: number;
    activePlayer: 'contestant' | 'chaser';
  }) => void;
}

type TurnPhase = 'contestant-answering' | 'contestant-feedback' | 'chaser-thinking' | 'chaser-feedback' | 'time-bonus';

const TimedBattlePhase: React.FC<TimedBattlePhaseProps> = ({
  contestantStartTime,
  chaserStartTime,
  difficulty,
  isAIControlled,
  questions,
  onComplete,
  onExit,
  onStateUpdate
}) => {
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [activePlayer, setActivePlayer] = useState<'contestant' | 'chaser'>('contestant');
  const [turnPhase, setTurnPhase] = useState<TurnPhase>('contestant-answering');
  const [contestantAnswer, setContestantAnswer] = useState<number | null>(null);
  const [chaserAnswer, setChaserAnswer] = useState<number | null>(null);
  const [showTimeBonus, setShowTimeBonus] = useState(false);
  const [gameEnded, setGameEnded] = useState(false);

  // Get chaser AI hook
  const { getChaserAnswer, isThinking } = useChaserAI({
    difficulty,
    thinkingDelayMs: CHASER_THINKING_DELAY
  });

  const currentQuestion = questions[currentQuestionIndex];

  // Contestant timer - only runs during contestant's turn
  const contestantTimer = useTimer({
    initialSeconds: contestantStartTime,
    autoStart: true, // Start immediately (contestant goes first)
    onComplete: () => {
      if (!gameEnded) {
        setGameEnded(true);
        onComplete('chaser'); // Contestant timer expired = chaser wins
      }
    }
  });

  // Chaser timer - only runs during chaser's turn
  const chaserTimer = useTimer({
    initialSeconds: chaserStartTime,
    autoStart: false,
    onComplete: () => {
      if (!gameEnded) {
        setGameEnded(true);
        onComplete('contestant'); // Chaser timer expired = contestant wins
      }
    }
  });

  // Sync state to parent for student view
  useEffect(() => {
    onStateUpdate?.({
      contestantTime: contestantTimer.timeRemaining,
      chaserTime: chaserTimer.timeRemaining,
      activePlayer
    });
  }, [contestantTimer.timeRemaining, chaserTimer.timeRemaining, activePlayer, onStateUpdate]);

  // Handle contestant answer
  const handleContestantAnswer = useCallback(async (selectedIndex: number) => {
    if (turnPhase !== 'contestant-answering' || gameEnded) return;

    contestantTimer.pause();
    setContestantAnswer(selectedIndex);
    setTurnPhase('contestant-feedback');

    const isCorrect = selectedIndex === currentQuestion.correctAnswerIndex;

    // Brief feedback (800ms)
    await new Promise(resolve => setTimeout(resolve, 800));

    // Switch to chaser's turn regardless of answer
    setActivePlayer('chaser');
    setTurnPhase('chaser-thinking');

    // Start chaser's timer
    chaserTimer.start();

    // Handle chaser's turn (AI or manual)
    if (isAIControlled) {
      const chaserIdx = await getChaserAnswer(currentQuestion);
      handleChaserAnswer(chaserIdx);
    }
    // If manual control, wait for teacher to click answer
  }, [turnPhase, gameEnded, currentQuestion, contestantTimer, chaserTimer, isAIControlled, getChaserAnswer]);

  // Handle chaser answer
  const handleChaserAnswer = useCallback(async (selectedIndex: number) => {
    if (turnPhase !== 'chaser-thinking' || gameEnded) return;

    chaserTimer.pause();
    setChaserAnswer(selectedIndex);
    setTurnPhase('chaser-feedback');

    const isCorrect = selectedIndex === currentQuestion.correctAnswerIndex;

    // If chaser got it wrong, contestant gets time bonus
    if (!isCorrect) {
      setTurnPhase('time-bonus');
      setShowTimeBonus(true);

      // Add time to contestant's clock
      const newTime = Math.min(contestantTimer.timeRemaining + TIME_BONUS_AMOUNT, 120); // Cap at 2 min
      contestantTimer.reset(newTime);

      // Wait for animation
      await new Promise(resolve => setTimeout(resolve, 1200));
      setShowTimeBonus(false);
    } else {
      // Brief feedback (800ms)
      await new Promise(resolve => setTimeout(resolve, 800));
    }

    // Move to next question
    if (currentQuestionIndex < questions.length - 1) {
      setCurrentQuestionIndex(prev => prev + 1);
      setContestantAnswer(null);
      setChaserAnswer(null);
      setActivePlayer('contestant');
      setTurnPhase('contestant-answering');
      contestantTimer.start();
    } else {
      // Out of questions - compare timers
      const winner = contestantTimer.timeRemaining >= chaserTimer.timeRemaining
        ? 'contestant'
        : 'chaser';
      setGameEnded(true);
      onComplete(winner);
    }
  }, [turnPhase, gameEnded, currentQuestion, currentQuestionIndex, questions.length, contestantTimer, chaserTimer, onComplete]);

  // Keyboard shortcuts (1-4) for contestant turn
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (turnPhase === 'contestant-answering' && e.key >= '1' && e.key <= '4') {
        handleContestantAnswer(parseInt(e.key) - 1);
      }
      // Manual chaser control
      if (!isAIControlled && turnPhase === 'chaser-thinking' && e.key >= '1' && e.key <= '4') {
        handleChaserAnswer(parseInt(e.key) - 1);
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [turnPhase, handleContestantAnswer, handleChaserAnswer, isAIControlled]);

  return (
    <div className="w-full h-full bg-gradient-to-br from-blue-950 via-slate-900 to-red-950 flex flex-col p-6">
      {/* Time Bonus Effect */}
      <TimeBonusEffect show={showTimeBonus} amount={TIME_BONUS_AMOUNT} />

      {/* Dual Timer Display */}
      <DualTimerDisplay
        contestantTime={contestantTimer.timeRemaining}
        chaserTime={chaserTimer.timeRemaining}
        activePlayer={activePlayer}
      />

      {/* Turn Indicator */}
      <div className="text-center mb-4">
        <span className={`inline-block px-4 py-2 rounded-full text-sm font-bold uppercase tracking-wider ${
          activePlayer === 'contestant'
            ? 'bg-blue-500/30 text-blue-300'
            : 'bg-red-500/30 text-red-300'
        }`}>
          {turnPhase === 'contestant-answering' && 'Contestant - Answer Now!'}
          {turnPhase === 'contestant-feedback' && (
            contestantAnswer === currentQuestion?.correctAnswerIndex ? 'Correct!' : 'Incorrect'
          )}
          {turnPhase === 'chaser-thinking' && (isThinking ? 'Chaser is thinking...' : 'Chaser - Answer Now!')}
          {turnPhase === 'chaser-feedback' && (
            chaserAnswer === currentQuestion?.correctAnswerIndex ? 'Chaser Correct' : 'Chaser Incorrect'
          )}
          {turnPhase === 'time-bonus' && 'Time Bonus!'}
        </span>
      </div>

      {/* Question Card */}
      <div className="flex-1 flex flex-col justify-center max-w-4xl mx-auto w-full">
        {/* Question */}
        <div className="bg-slate-800/60 p-6 md:p-8 rounded-2xl border-2 border-slate-600 mb-6">
          <div className="text-xs text-slate-400 uppercase tracking-wider mb-2">
            Question {currentQuestionIndex + 1} of {questions.length}
          </div>
          <p className="text-xl md:text-2xl font-bold text-white leading-relaxed text-center">
            {currentQuestion?.question}
          </p>
        </div>

        {/* Answer Options - 2x2 Grid */}
        <div className="grid grid-cols-2 gap-4">
          {currentQuestion?.options.map((option, idx) => {
            const isContestantAnswer = contestantAnswer === idx;
            const isChaserAnswer = chaserAnswer === idx;
            const isCorrect = idx === currentQuestion.correctAnswerIndex;
            const showResult = turnPhase === 'contestant-feedback' ||
                              turnPhase === 'chaser-feedback' ||
                              turnPhase === 'time-bonus';

            return (
              <button
                key={idx}
                onClick={() => {
                  if (turnPhase === 'contestant-answering') handleContestantAnswer(idx);
                  if (!isAIControlled && turnPhase === 'chaser-thinking') handleChaserAnswer(idx);
                }}
                disabled={turnPhase !== 'contestant-answering' && (isAIControlled || turnPhase !== 'chaser-thinking')}
                className={`
                  p-5 rounded-xl text-left font-bold text-lg transition-all duration-150 border-2
                  ${isContestantAnswer && !showResult ? 'bg-blue-500 border-blue-400 text-white' : ''}
                  ${isChaserAnswer && turnPhase !== 'contestant-feedback' && !showResult ? 'bg-red-500 border-red-400 text-white' : ''}
                  ${!isContestantAnswer && !isChaserAnswer ? 'bg-slate-700 border-slate-600 text-white hover:bg-slate-600 hover:border-slate-500' : ''}
                  ${showResult && isCorrect ? 'bg-green-600 border-green-400 text-white' : ''}
                  ${showResult && !isCorrect && (isContestantAnswer || isChaserAnswer) ? 'bg-slate-700/50 border-slate-600 opacity-50' : ''}
                  ${showResult && !isCorrect && !isContestantAnswer && !isChaserAnswer ? 'opacity-30' : ''}
                `}
              >
                <span className="text-slate-400 mr-3">{idx + 1}.</span>
                {option}
              </button>
            );
          })}
        </div>

        {/* Keyboard hint */}
        <p className="text-center text-slate-500 text-sm mt-4">
          {turnPhase === 'contestant-answering' && 'Press 1-4 to answer'}
          {!isAIControlled && turnPhase === 'chaser-thinking' && 'Press 1-4 for chaser answer'}
        </p>
      </div>

      {/* Exit button */}
      <div className="mt-4 flex justify-center">
        <button
          onClick={onExit}
          className="px-6 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-lg transition-colors"
        >
          End Game
        </button>
      </div>
    </div>
  );
};

export default TimedBattlePhase;
```

Key mechanics:
- Contestant goes first, timer starts immediately
- Pause timer when answering, resume after feedback
- Chaser turn: AI auto-answers after thinking delay OR manual control
- Time bonus: +5s to contestant when chaser is wrong
- Game ends when a timer hits 0 OR questions exhausted (compare remaining time)
  </action>
  <verify>TypeScript compiles without errors: `cd "/Users/ricky/Documents/App_Projects/Education Apps/DEV - PiPi" && npx tsc --noEmit`</verify>
  <done>TimedBattlePhase implements turn-based mechanics with dual timers, catch-up bonus, and instant loss on timer expiry</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. DualTimerDisplay shows both timers with active/inactive states
3. TimeBonusEffect animates +5s floating text
4. TimedBattlePhase correctly manages turn switching and timer control
5. Timer expiry immediately triggers game over
</verification>

<success_criteria>
- Dual timers display side-by-side (contestant left, chaser right)
- Active player's timer glows, inactive timer is dimmed
- Only active player's timer counts down
- Contestant earns +5s when chaser answers incorrectly
- Timer reaching 0 = instant loss for that player
- AI chaser uses useChaserAI hook with 1000ms thinking delay
</success_criteria>

<output>
After completion, create `.planning/phases/24-beat-the-chaser/24-03-SUMMARY.md`
</output>
