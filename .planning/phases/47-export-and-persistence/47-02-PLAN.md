---
phase: 47-export-and-persistence
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - types.ts
  - services/saveService.ts
  - services/loadService.ts
  - App.tsx
  - components/ResourceHub.tsx
autonomous: true

must_haves:
  truths:
    - "Enhanced resources persist when user saves presentation as .cue file"
    - "Enhanced resources restore exactly as saved when loading .cue file"
    - "User edits to enhanced content are preserved across save/load"
    - "Loading a v3 .cue file migrates successfully to v4"
  artifacts:
    - path: "types.ts"
      provides: "SerializedEditState, EnhancedResourceState, CueFileContent v4"
      contains: "CURRENT_FILE_VERSION = 4"
    - path: "services/saveService.ts"
      provides: "Enhanced resource serialization"
      exports: ["createCueFile"]
    - path: "services/loadService.ts"
      provides: "Enhanced resource deserialization and migration"
      exports: ["readCueFile"]
  key_links:
    - from: "services/saveService.ts"
      to: "types.ts"
      via: "SerializedEditState type"
      pattern: "SerializedEditState"
    - from: "services/loadService.ts"
      to: "types.ts"
      via: "EnhancedResourceState type"
      pattern: "EnhancedResourceState"
    - from: "App.tsx"
      to: "services/saveService.ts"
      via: "createCueFile with enhanced resources"
      pattern: "createCueFile\\("
    - from: "App.tsx"
      to: "services/loadService.ts"
      via: "readCueFile restoring enhanced resources"
      pattern: "readCueFile\\("
---

<objective>
Enable enhanced resources to persist within .cue files so teachers can save and reload their work across sessions.

Purpose: Teachers invest time enhancing resources and editing AI output. This must persist when they save their presentation, and restore exactly when they load it later. The CueFile format is extended to v4 with enhanced resource support.

Output: Updated types.ts with v4 schema, saveService.ts with enhanced resource serialization, loadService.ts with deserialization and migration, App.tsx and ResourceHub.tsx wired to pass data through save/load flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-export-and-persistence/47-CONTEXT.md
@.planning/phases/47-export-and-persistence/47-RESEARCH.md

# Existing files to extend
@types.ts
@services/saveService.ts
@services/loadService.ts
@App.tsx
@components/ResourceHub.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add persistence types and update CueFile to v4</name>
  <files>
    types.ts
  </files>
  <action>
Modify types.ts to add enhanced resource persistence types:

1. Add SerializedEditState interface (for JSON serialization of Map):
```typescript
// Serializable edit state (Map doesn't serialize to JSON)
export interface SerializedEditState {
  simple: [number, string][];   // Array of [position, content] tuples
  standard: [number, string][];
  detailed: [number, string][];
}
```

2. Add EnhancedResourceState interface:
```typescript
// Enhanced resource state for .cue file persistence
export interface EnhancedResourceState {
  resourceId: string;                    // Links to UploadedResource.id
  originalResource: UploadedResource;    // Full resource data
  analysis: DocumentAnalysis;            // Cached analysis
  enhancementResult: EnhancementResult;  // All three versions + answer keys
  editOverlays: SerializedEditState;     // User edits stored separately
  enhancedAt: string;                    // ISO 8601 timestamp
}
```

3. Update CURRENT_FILE_VERSION:
```typescript
export const CURRENT_FILE_VERSION = 4;  // Bump from 3
```

4. Update CueFileContent interface to add enhancedResources:
```typescript
export interface CueFileContent {
  slides: Slide[];
  studentNames: string[];
  lessonText: string;
  studentGrades?: StudentWithGrade[];
  enhancedResources?: EnhancedResourceState[];  // NEW in v4
}
```

Place these new types near the existing EditState type (after line ~434 in current file) for logical grouping.
  </action>
  <verify>
1. TypeScript compiles: npm run typecheck passes
2. Types are exported (visible in editor autocomplete)
3. CURRENT_FILE_VERSION = 4
  </verify>
  <done>
types.ts updated with SerializedEditState, EnhancedResourceState, and CueFileContent v4 schema.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update saveService with enhanced resource serialization</name>
  <files>
    services/saveService.ts
  </files>
  <action>
Modify saveService.ts to handle enhanced resources:

1. Update imports to include new types:
```typescript
import {
  Slide,
  CueFile,
  CURRENT_FILE_VERSION,
  StudentWithGrade,
  EnhancedResourceState,
  SerializedEditState
} from '../types';
```

2. Add serializeEditState helper function:
```typescript
/**
 * Serialize EditState Maps to JSON-compatible format.
 * Maps don't serialize to JSON directly, so convert to array tuples.
 */
export function serializeEditState(
  edits: Record<'simple' | 'standard' | 'detailed', Map<number, string>>
): SerializedEditState {
  return {
    simple: Array.from(edits.simple.entries()),
    standard: Array.from(edits.standard.entries()),
    detailed: Array.from(edits.detailed.entries())
  };
}
```

3. Update createCueFile signature and implementation:
   - Add parameter: enhancedResources?: EnhancedResourceState[]
   - Include in returned CueFileContent if present and non-empty:
```typescript
export function createCueFile(
  title: string,
  slides: Slide[],
  studentNames: string[],
  lessonText: string,
  existingFile?: CueFile,
  studentGrades?: StudentWithGrade[],
  deckVerbosity?: VerbosityLevel,
  enhancedResources?: EnhancedResourceState[]
): CueFile {
  const now = new Date().toISOString();

  return {
    version: CURRENT_FILE_VERSION,
    createdAt: existingFile?.createdAt ?? now,
    modifiedAt: now,
    title,
    ...(deckVerbosity && deckVerbosity !== 'standard' ? { deckVerbosity } : {}),
    content: {
      slides,
      studentNames,
      lessonText,
      ...(studentGrades && studentGrades.length > 0 ? { studentGrades } : {}),
      ...(enhancedResources && enhancedResources.length > 0 ? { enhancedResources } : {}),
    },
  };
}
```

Note: The serializeEditState function is exported so App.tsx can use it when preparing EnhancedResourceState for saving.
  </action>
  <verify>
1. TypeScript compiles: npm run typecheck
2. createCueFile accepts enhancedResources parameter
3. serializeEditState is exported
  </verify>
  <done>
saveService.ts updated with enhanced resource serialization support.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update loadService with deserialization and v3->v4 migration</name>
  <files>
    services/loadService.ts
  </files>
  <action>
Modify loadService.ts to handle enhanced resource loading and migration:

1. Update imports:
```typescript
import {
  CueFile,
  CURRENT_FILE_VERSION,
  SerializedEditState,
  EditState
} from '../types';
```

2. Add deserializeEditState helper function:
```typescript
/**
 * Deserialize JSON edit state back to Maps.
 */
export function deserializeEditState(serialized: SerializedEditState): EditState {
  return {
    edits: {
      simple: new Map(serialized.simple),
      standard: new Map(serialized.standard),
      detailed: new Map(serialized.detailed)
    }
  };
}
```

3. Update migrateFile function to handle v3 -> v4 migration:
```typescript
function migrateFile(data: CueFile): CueFile {
  let migrated = data;

  if (data.version < CURRENT_FILE_VERSION) {
    console.log(`Migrating file from version ${data.version} to ${CURRENT_FILE_VERSION}`);

    // v1 -> v2: Added verbosityCache to Slide interface
    // No action needed - optional field defaults to undefined

    // v2 -> v3: Added deckVerbosity to CueFile root
    // No action needed - deckVerbosity is optional

    // v3 -> v4: Added enhancedResources to CueFileContent
    if (data.version < 4) {
      migrated = {
        ...migrated,
        content: {
          ...migrated.content,
          enhancedResources: []  // Default empty array for older files
        }
      };
    }
  }

  return {
    ...migrated,
    version: CURRENT_FILE_VERSION,
  };
}
```

Note: Migration is trivial since enhancedResources is optional and defaults to empty array. Existing v3 files will load with no enhanced resources, which is correct behavior.
  </action>
  <verify>
1. TypeScript compiles: npm run typecheck
2. deserializeEditState is exported
3. Loading an older .cue file (v3) succeeds and migrates to v4
  </verify>
  <done>
loadService.ts updated with enhanced resource deserialization and v3->v4 migration.
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire App.tsx and ResourceHub to pass enhanced resources through save/load</name>
  <files>
    App.tsx
    components/ResourceHub.tsx
  </files>
  <action>
This task wires the enhanced resource data through the save/load flow.

**In App.tsx:**

1. Add state for enhanced resources at presentation level (near other presentation state):
```typescript
const [enhancedResourceStates, setEnhancedResourceStates] = useState<EnhancedResourceState[]>([]);
```

2. Update handleSave to include enhanced resources:
   - Find where createCueFile is called
   - Pass enhancedResourceStates as the new parameter

3. Update file load handling to restore enhanced resources:
   - After readCueFile returns, extract content.enhancedResources
   - Call setEnhancedResourceStates(loadedFile.content.enhancedResources || [])

4. Pass enhancedResourceStates and setEnhancedResourceStates to ResourceHub via props:
```typescript
<ResourceHub
  ...existing props...
  enhancedResourceStates={enhancedResourceStates}
  onEnhancedResourcesChange={setEnhancedResourceStates}
/>
```

**In ResourceHub.tsx:**

1. Update ResourceHubProps interface:
```typescript
interface ResourceHubProps {
  ...existing props...
  enhancedResourceStates?: EnhancedResourceState[];
  onEnhancedResourcesChange?: (states: EnhancedResourceState[]) => void;
}
```

2. Restore enhanced resources on mount:
   - When component mounts, if enhancedResourceStates is provided:
   - Restore uploadedResources from enhancedResourceStates[].originalResource
   - Restore resourceAnalysis from enhancedResourceStates[].analysis

3. Update EnhancementPanel integration:
   - Pass a callback to capture enhancement completion
   - When enhancement completes, create EnhancedResourceState and update parent
   - Include edit state serialization when creating the state

4. Track edit state changes in EnhancementPanel and bubble up to ResourceHub:
   - This requires adding an onEditStateChange callback prop to EnhancementPanel
   - Or: Store edit state at ResourceHub level and pass down

**Simplified approach (recommended):**
Since EnhancementPanel already manages edit state internally, add a useEffect that bubbles up state changes:

In EnhancementPanel.tsx (minor addition):
- Add onStateChange?: (state: { result: EnhancementResult | null, editState: EditState }) => void to props
- Add useEffect to call onStateChange when result or editState changes

In ResourceHub.tsx:
- Track enhancement state per resource
- When saving, serialize current state to EnhancedResourceState
- Pass to onEnhancedResourcesChange

This ensures the save operation captures current state without complex prop drilling.
  </action>
  <verify>
1. TypeScript compiles: npm run typecheck
2. npm run build succeeds
3. Manual verification flow:
   a. Upload a resource
   b. Complete enhancement
   c. Make an edit to the enhanced content
   d. Save presentation (.cue file)
   e. Close and reload the app
   f. Load the saved .cue file
   g. Verify: Enhanced resource appears with all content and edits intact
  </verify>
  <done>
App.tsx and ResourceHub.tsx wired to persist and restore enhanced resources via .cue file save/load.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: npm run typecheck passes
2. Build: npm run build succeeds
3. Migration test:
   - Load an existing v3 .cue file
   - Verify it opens without errors
   - Save it again and verify version is now 4
4. Full persistence test:
   - Create new presentation with slides
   - Upload and enhance a resource
   - Edit some enhanced content
   - Save as .cue file
   - Close browser / refresh
   - Load the .cue file
   - Verify:
     - Enhanced resource appears in ResourceHub
     - All three differentiation levels preserved
     - User edits are preserved
     - Analysis is preserved (no re-analysis needed)
</verification>

<success_criteria>
- Enhanced resources save within .cue file on presentation save
- Enhanced resources restore completely when loading .cue file
- User edits to AI content persist across save/load cycle
- v3 files migrate cleanly to v4 with empty enhanced resources
</success_criteria>

<output>
After completion, create `.planning/phases/47-export-and-persistence/47-02-SUMMARY.md`
</output>
