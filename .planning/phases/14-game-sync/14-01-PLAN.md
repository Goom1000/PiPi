---
phase: 14-game-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - types.ts
  - components/PresentationView.tsx
autonomous: true

must_haves:
  truths:
    - "When teacher opens game, GAME_STATE_UPDATE message is broadcast"
    - "Game state changes (question advance, reveal) trigger broadcasts"
    - "When teacher closes game, GAME_CLOSE message is broadcast"
  artifacts:
    - path: "types.ts"
      provides: "GameSyncState interface and game message types"
      contains: "GAME_STATE_UPDATE"
    - path: "components/PresentationView.tsx"
      provides: "Game state broadcasting logic"
      contains: "GAME_STATE_UPDATE"
  key_links:
    - from: "components/PresentationView.tsx"
      to: "types.ts"
      via: "GameSyncState import"
      pattern: "import.*GameSyncState"
    - from: "QuizOverlay state changes"
      to: "postMessage"
      via: "useEffect broadcast"
      pattern: "postMessage.*GAME_STATE_UPDATE"
---

<objective>
Add game sync types and broadcast game state from teacher view

Purpose: Enable PresentationView to broadcast quiz/game state so StudentView can receive it (Plan 02)
Output: Extended PresentationMessage type with game messages, PresentationView broadcasting game state
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-game-sync/14-CONTEXT.md
@.planning/phases/14-game-sync/14-RESEARCH.md
@types.ts
@components/PresentationView.tsx
@hooks/useBroadcastSync.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add game sync types to types.ts</name>
  <files>types.ts</files>
  <action>
Add GameSyncState interface and extend PresentationMessage union:

1. Import QuizQuestion type at the top (add to existing imports or add new import):
   ```typescript
   import { QuizQuestion } from './services/geminiService';
   ```

2. Add GameSyncState interface after PresentationState:
   ```typescript
   // Game state synchronized from teacher to student view
   export interface GameSyncState {
     mode: 'loading' | 'play' | 'summary';
     questions: QuizQuestion[];
     currentQuestionIndex: number;
     isAnswerRevealed: boolean;
   }
   ```

3. Extend PresentationMessage discriminated union with two new message types:
   ```typescript
   export type PresentationMessage =
     | { type: 'STATE_UPDATE'; payload: PresentationState }
     | { type: 'STATE_REQUEST' }
     | { type: 'HEARTBEAT'; timestamp: number }
     | { type: 'HEARTBEAT_ACK'; timestamp: number }
     | { type: 'CLOSE_STUDENT' }
     | { type: 'GAME_STATE_UPDATE'; payload: GameSyncState }
     | { type: 'GAME_CLOSE' };
   ```

Note: Only sync 'loading', 'play', 'summary' modes - NOT 'setup' (teacher-only configuration screen).
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>GameSyncState interface exists, PresentationMessage includes GAME_STATE_UPDATE and GAME_CLOSE types</done>
</task>

<task type="auto">
  <name>Task 2: Broadcast game state from PresentationView</name>
  <files>components/PresentationView.tsx</files>
  <action>
Modify PresentationView to broadcast game state when QuizOverlay is active.

1. Import GameSyncState from types.ts:
   ```typescript
   import { Slide, PresentationMessage, BROADCAST_CHANNEL_NAME, GameSyncState } from '../types';
   ```

2. Lift game state from QuizOverlay to PresentationView. Add state variable after isQuizModalOpen:
   ```typescript
   const [gameState, setGameState] = useState<GameSyncState | null>(null);
   ```

3. Add useEffect to broadcast game state changes (add after existing broadcast useEffect around line 287):
   ```typescript
   // Broadcast game state changes to student window
   useEffect(() => {
     if (gameState) {
       postMessage({
         type: 'GAME_STATE_UPDATE',
         payload: gameState
       });
     } else if (isQuizModalOpen === false) {
       // Only send GAME_CLOSE when explicitly closing (not on initial mount)
       // Check if we ever had game state to avoid spurious close on mount
     }
   }, [gameState, postMessage]);
   ```

   Better approach - track if game was ever opened:
   ```typescript
   const gameWasOpenRef = useRef(false);

   useEffect(() => {
     if (gameState) {
       gameWasOpenRef.current = true;
       postMessage({
         type: 'GAME_STATE_UPDATE',
         payload: gameState
       });
     } else if (gameWasOpenRef.current) {
       postMessage({ type: 'GAME_CLOSE' });
       gameWasOpenRef.current = false;
     }
   }, [gameState, postMessage]);
   ```

4. Modify QuizOverlay component to report state changes via callback prop.

   Add new prop to QuizOverlay interface:
   ```typescript
   const QuizOverlay: React.FC<{
       slides: Slide[];
       currentIndex: number;
       onClose: () => void;
       provider: AIProviderInterface | null;
       onError: (title: string, message: string) => void;
       onRequestAI: (featureName: string) => void;
       onGameStateChange: (state: GameSyncState | null) => void;  // NEW
   }> = ({ slides, currentIndex, onClose, provider, onError, onRequestAI, onGameStateChange }) => {
   ```

5. Inside QuizOverlay, add useEffect to report state changes:
   ```typescript
   // Report game state changes to parent for broadcast
   useEffect(() => {
     // Only report syncable modes (not 'setup' which is teacher-only)
     if (mode === 'loading' || mode === 'play' || mode === 'summary') {
       onGameStateChange({
         mode,
         questions,
         currentQuestionIndex: qIndex,
         isAnswerRevealed: reveal
       });
     }
   }, [mode, questions, qIndex, reveal, onGameStateChange]);

   // Report null when closing (cleanup)
   useEffect(() => {
     return () => onGameStateChange(null);
   }, [onGameStateChange]);
   ```

6. Update QuizOverlay usage in the portal (around line 609) to pass the callback:
   ```typescript
   {isQuizModalOpen && createPortal(
       <QuizOverlay
           slides={slides}
           currentIndex={currentIndex}
           onClose={() => setIsQuizModalOpen(false)}
           provider={provider}
           onError={onError}
           onRequestAI={onRequestAI}
           onGameStateChange={setGameState}  // NEW
       />,
       document.body
   )}
   ```

7. Also include game state in STATE_REQUEST response (for late-joining students). Modify the existing STATE_REQUEST handler (around line 272):
   ```typescript
   useEffect(() => {
     if (lastMessage?.type === 'STATE_REQUEST') {
       // Student connected, send current state
       postMessage({
         type: 'STATE_UPDATE',
         payload: { currentIndex, visibleBullets, slides }
       });
       // If game is active, also send game state
       if (gameState) {
         postMessage({
           type: 'GAME_STATE_UPDATE',
           payload: gameState
         });
       }
     }
   }, [lastMessage, currentIndex, visibleBullets, slides, postMessage, gameState]);
   ```
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Run the app, open presentation mode, click "Game Mode", verify no console errors
3. Open browser DevTools console, add: `new BroadcastChannel('pipi-presentation').onmessage = e => console.log('BC:', e.data)`
4. Start a quiz - should see GAME_STATE_UPDATE messages logged
5. Close quiz - should see GAME_CLOSE message logged
  </verify>
  <done>
- QuizOverlay reports state changes via callback
- PresentationView broadcasts GAME_STATE_UPDATE when game active
- PresentationView broadcasts GAME_CLOSE when game closes
- Late-joining students receive game state on STATE_REQUEST
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. No regressions: App loads, presentation mode works, quiz still functions for teacher
3. BroadcastChannel test: Messages are sent when game state changes
</verification>

<success_criteria>
- GameSyncState type defined in types.ts
- PresentationMessage includes GAME_STATE_UPDATE and GAME_CLOSE
- PresentationView broadcasts game state changes
- GAME_CLOSE sent when quiz modal closes
- STATE_REQUEST response includes game state if active
</success_criteria>

<output>
After completion, create `.planning/phases/14-game-sync/14-01-SUMMARY.md`
</output>
