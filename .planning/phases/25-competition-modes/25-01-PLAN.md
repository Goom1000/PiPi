---
phase: 25-competition-modes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - types.ts
  - utils/teamNameGenerator.ts
autonomous: true

must_haves:
  truths:
    - "CompetitionMode type can distinguish individual from team mode"
    - "Team name generator produces kid-friendly two-word names instantly"
    - "Types integrate with existing discriminated union patterns"
  artifacts:
    - path: "types.ts"
      provides: "CompetitionMode discriminated union"
      contains: "type CompetitionMode"
    - path: "utils/teamNameGenerator.ts"
      provides: "Team name generation utility"
      exports: ["generateTeamNames", "Team"]
  key_links:
    - from: "types.ts"
      to: "CompetitionMode"
      via: "discriminated union with mode literal"
      pattern: "mode: 'individual' | mode: 'team'"
---

<objective>
Define CompetitionMode type system and create team name generator utility.

Purpose: Establish type-safe foundation for competition modes that matches existing GameState discriminated union patterns. Team name generator provides instant kid-friendly names without external dependencies.

Output: Extended types.ts with CompetitionMode, new utils/teamNameGenerator.ts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-competition-modes/25-CONTEXT.md
@.planning/phases/25-competition-modes/25-RESEARCH.md
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define CompetitionMode types</name>
  <files>types.ts</files>
  <action>
Add CompetitionMode discriminated union type to types.ts after the GameDifficulty type:

```typescript
// Competition mode for team/individual play
export interface Team {
  id: string;      // crypto.randomUUID()
  name: string;
  score: number;
}

export type CompetitionMode =
  | { mode: 'individual'; playerName: string }
  | { mode: 'team'; teams: Team[]; activeTeamIndex: number };
```

Key decisions:
- Team has stable `id` for React keys (not array index)
- `activeTeamIndex` tracks which team's turn it is
- `score` is per-team, managed by orchestrator
- `playerName` can be empty string (defaults to "Player" in UI)
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Search for export: `grep "type CompetitionMode" types.ts`
  </verify>
  <done>
CompetitionMode type exported from types.ts with individual and team variants
  </done>
</task>

<task type="auto">
  <name>Task 2: Create team name generator utility</name>
  <files>utils/teamNameGenerator.ts</files>
  <action>
Create new file `utils/teamNameGenerator.ts`:

```typescript
import { Team } from '../types';

// Kid-friendly adjectives (~20 curated words)
const ADJECTIVES = [
  'Amazing', 'Brilliant', 'Clever', 'Daring', 'Epic',
  'Fearless', 'Gigantic', 'Happy', 'Incredible', 'Jolly',
  'Keen', 'Lively', 'Mighty', 'Noble', 'Outstanding',
  'Powerful', 'Quick', 'Radiant', 'Super', 'Terrific'
];

// Kid-friendly nouns (~20 curated animals/objects)
const NOUNS = [
  'Dragons', 'Eagles', 'Falcons', 'Griffins', 'Hawks',
  'Jaguars', 'Knights', 'Lions', 'Meteors', 'Ninjas',
  'Owls', 'Panthers', 'Phoenixes', 'Rockets', 'Sharks',
  'Tigers', 'Unicorns', 'Vikings', 'Wizards', 'Wolves'
];

/**
 * Fisher-Yates shuffle for random ordering.
 * Returns new array, does not mutate input.
 */
function shuffle<T>(array: T[]): T[] {
  const copy = [...array];
  for (let i = copy.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [copy[i], copy[j]] = [copy[j], copy[i]];
  }
  return copy;
}

/**
 * Generate an array of unique team names.
 * Names follow "Adjective Noun" pattern (e.g., "Mighty Dragons").
 * With 20 adjectives x 20 nouns = 400 possible combinations.
 *
 * @param count Number of team names to generate
 * @returns Array of unique two-word team names
 */
export function generateTeamNames(count: number): string[] {
  const shuffledAdj = shuffle(ADJECTIVES);
  const shuffledNouns = shuffle(NOUNS);

  return Array.from({ length: count }, (_, i) =>
    `${shuffledAdj[i % shuffledAdj.length]} ${shuffledNouns[i % shuffledNouns.length]}`
  );
}

/**
 * Create initial Team objects with generated names and zero scores.
 * Each team gets a unique UUID for stable React keys.
 *
 * @param count Number of teams to create
 * @returns Array of Team objects ready for game state
 */
export function createTeams(count: number): Team[] {
  const names = generateTeamNames(count);
  return names.map(name => ({
    id: crypto.randomUUID(),
    name,
    score: 0
  }));
}
```

Key decisions per RESEARCH.md:
- In-memory word lists (no external dependencies)
- Fisher-Yates shuffle for true randomness
- Instant generation (no async/API calls)
- Words curated for children aged ~10
  </action>
  <verify>
File exists: `ls utils/teamNameGenerator.ts`
TypeScript compiles: `npx tsc --noEmit`
Test generation: Create a quick test in browser console or Node
  </verify>
  <done>
Team name generator exports generateTeamNames and createTeams functions
  </done>
</task>

</tasks>

<verification>
```bash
# TypeScript compiles without errors
npx tsc --noEmit

# Types are exported
grep "type CompetitionMode" types.ts
grep "export function generateTeamNames" utils/teamNameGenerator.ts
grep "export function createTeams" utils/teamNameGenerator.ts
```
</verification>

<success_criteria>
- [ ] CompetitionMode type defined with 'individual' and 'team' variants
- [ ] Team interface with id, name, score fields
- [ ] generateTeamNames function returns array of kid-friendly names
- [ ] createTeams function returns array of Team objects with UUIDs
- [ ] All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/25-competition-modes/25-01-SUMMARY.md`
</output>
