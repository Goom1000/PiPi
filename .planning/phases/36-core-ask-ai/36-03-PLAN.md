---
phase: 36-core-ask-ai
plan: 03
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - services/providers/claudeProvider.ts
autonomous: true

must_haves:
  truths:
    - "Claude provider streamChat yields text chunks parsed from SSE response"
    - "SSE parsing handles partial chunks correctly with buffer"
    - "System prompt instructs age-appropriate language based on gradeLevel"
  artifacts:
    - path: "services/providers/claudeProvider.ts"
      provides: "streamChat method with SSE parsing"
  key_links:
    - from: "services/providers/claudeProvider.ts"
      to: "api.anthropic.com"
      via: "fetch with stream: true and SSE parsing"
      pattern: "stream.*true"
---

<objective>
Implement streaming chat for Claude provider using SSE parsing.

Purpose: Enable Ask AI to stream responses from Claude, parsing Server-Sent Events (SSE) to yield text chunks as they arrive.

Output: streamChat method in ClaudeProvider that fetches with stream:true and parses the text/event-stream response.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/36-core-ask-ai/36-RESEARCH.md
@.planning/phases/36-core-ask-ai/36-01-SUMMARY.md

@services/aiProvider.ts
@services/providers/claudeProvider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add streamChat method to ClaudeProvider</name>
  <files>services/providers/claudeProvider.ts</files>
  <action>
Import ChatContext from aiProvider if not already imported:

```typescript
import {
  // ... existing imports
  ChatContext
} from '../aiProvider';
```

Add streamChat async generator method to ClaudeProvider class (place after other methods, before the private helper methods):

```typescript
  /**
   * Stream a chat response from Claude using SSE.
   * Parses text/event-stream manually since EventSource doesn't support POST.
   */
  async *streamChat(
    message: string,
    context: ChatContext
  ): AsyncGenerator<string, void, unknown> {
    const systemPrompt = `You are a helpful teaching assistant. The teacher is presenting a lesson to ${context.gradeLevel} students.

CURRENT LESSON CONTEXT:
- Topic: ${context.lessonTopic}
- Current Slide: ${context.currentSlideTitle}
- Slide Content: ${context.currentSlideContent.join('; ')}

INSTRUCTIONS:
- Give clear, helpful answers to the teacher's question
- Use language appropriate for ${context.gradeLevel} students
- Be concise but thorough
- If relevant, reference the lesson content
- Do NOT include markdown formatting (no **, no ##, no bullet points)
- Write in plain, conversational prose`;

    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': this.apiKey,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true',
      },
      body: JSON.stringify({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1024,
        stream: true,
        system: systemPrompt,
        messages: [{ role: 'user', content: message }],
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw this.createErrorFromResponse(response.status, errorText);
    }

    if (!response.body) {
      throw new AIProviderError(
        USER_ERROR_MESSAGES.NETWORK_ERROR,
        'NETWORK_ERROR'
      );
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || ''; // Keep incomplete line in buffer

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6);
            if (data === '[DONE]') continue;

            try {
              const parsed = JSON.parse(data);
              if (parsed.type === 'content_block_delta' &&
                  parsed.delta?.type === 'text_delta' &&
                  parsed.delta?.text) {
                yield parsed.delta.text;
              }
            } catch {
              // Skip non-JSON lines (like event: lines)
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }

  /**
   * Create appropriate AIProviderError from HTTP status.
   */
  private createErrorFromResponse(status: number, errorText: string): AIProviderError {
    let code: AIErrorCode = 'UNKNOWN_ERROR';
    let message = USER_ERROR_MESSAGES.UNKNOWN_ERROR;

    if (status === 401 || status === 403) {
      code = 'AUTH_ERROR';
      message = USER_ERROR_MESSAGES.AUTH_ERROR;
    } else if (status === 429) {
      // Check if quota or rate limit
      if (errorText.includes('quota') || errorText.includes('limit')) {
        code = 'QUOTA_EXCEEDED';
        message = USER_ERROR_MESSAGES.QUOTA_EXCEEDED;
      } else {
        code = 'RATE_LIMIT';
        message = USER_ERROR_MESSAGES.RATE_LIMIT;
      }
    } else if (status >= 500) {
      code = 'SERVER_ERROR';
      message = USER_ERROR_MESSAGES.SERVER_ERROR;
    }

    return new AIProviderError(message, code, errorText);
  }
```

Note: If createErrorFromResponse or similar helper already exists in the file, reuse it instead of adding a duplicate. Check existing error handling patterns in the file first.
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit 2>&1 | grep -E "(claudeProvider|error)" | head -10
```

streamChat method exists:
```bash
grep -n "streamChat" services/providers/claudeProvider.ts
```

SSE parsing present:
```bash
grep -n "content_block_delta" services/providers/claudeProvider.ts
```
  </verify>
  <done>ClaudeProvider.streamChat method implemented with SSE parsing, yields text chunks from Claude streaming API.</done>
</task>

<task type="auto">
  <name>Task 2: Verify error handling imports</name>
  <files>services/providers/claudeProvider.ts</files>
  <action>
Ensure AIProviderError, AIErrorCode, and USER_ERROR_MESSAGES are imported from aiProvider.

Check the existing imports at the top of the file. They should already include these from existing error handling. If not, add:

```typescript
import {
  AIProviderInterface,
  AIProviderError,
  AIErrorCode,
  USER_ERROR_MESSAGES,
  // ... other existing imports
  ChatContext
} from '../aiProvider';
```

Also verify that the existing error handling in the file (wrapError method, etc.) works with the new streamChat method. The pattern should be consistent with other methods in the class.
  </action>
  <verify>
Imports present:
```bash
grep -E "(AIProviderError|AIErrorCode|USER_ERROR_MESSAGES)" services/providers/claudeProvider.ts | head -3
```

TypeScript compiles:
```bash
npx tsc --noEmit 2>&1 | grep -E "claudeProvider" | head -5
```
  </verify>
  <done>All required imports present in claudeProvider.ts, error handling consistent with existing patterns.</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. TypeScript compiles without errors:
   ```bash
   npx tsc --noEmit 2>&1 | grep -E "(claude|error)" | head -10
   ```

2. streamChat method exists with SSE parsing:
   ```bash
   grep -A20 "async \*streamChat" services/providers/claudeProvider.ts | head -25
   ```

3. stream: true in request:
   ```bash
   grep "stream.*true" services/providers/claudeProvider.ts
   ```

4. Buffer handling for partial chunks:
   ```bash
   grep -n "buffer" services/providers/claudeProvider.ts
   ```
</verification>

<success_criteria>
- ClaudeProvider.streamChat yields text chunks from SSE response
- SSE parsing handles partial chunks with buffer (lines split across reads)
- System prompt includes gradeLevel for age-appropriate responses (CTXT-02)
- System prompt includes lesson context (CTXT-01)
- Error handling consistent with existing patterns
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/36-core-ask-ai/36-03-SUMMARY.md`
</output>
