---
phase: 02-multi-provider-ai
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/aiProvider.ts
  - services/providers/geminiProvider.ts
  - services/providers/claudeProvider.ts
  - services/providers/openaiProvider.ts
autonomous: true

must_haves:
  truths:
    - "Provider factory returns correct implementation based on provider type"
    - "Gemini provider wraps existing geminiService functions"
    - "Claude provider throws not-implemented for now (placeholder)"
    - "OpenAI provider throws CORS error immediately"
    - "All providers implement the same interface"
  artifacts:
    - path: "services/aiProvider.ts"
      provides: "AIProviderInterface, AIProviderError, createAIProvider factory"
      exports: ["AIProviderInterface", "AIProviderError", "AIErrorCode", "createAIProvider", "USER_ERROR_MESSAGES"]
    - path: "services/providers/geminiProvider.ts"
      provides: "GeminiProvider class implementing AIProviderInterface"
      exports: ["GeminiProvider"]
    - path: "services/providers/claudeProvider.ts"
      provides: "ClaudeProvider class (placeholder)"
      exports: ["ClaudeProvider"]
    - path: "services/providers/openaiProvider.ts"
      provides: "OpenAIProvider class that throws CORS error"
      exports: ["OpenAIProvider"]
  key_links:
    - from: "services/aiProvider.ts"
      to: "services/providers/*Provider.ts"
      via: "imports and factory switch"
      pattern: "import.*Provider.*from.*providers"
---

<objective>
Create the AI provider abstraction layer with unified interface, error handling, and factory function.

Purpose: Establish the foundation for multi-provider support. All providers implement the same interface, making it trivial to swap implementations. Error handling is unified so UI code can display user-friendly messages regardless of which provider failed.

Output: `services/aiProvider.ts` with types and factory, `services/providers/` directory with three provider implementations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-multi-provider-ai/02-CONTEXT.md
@.planning/phases/02-multi-provider-ai/02-RESEARCH.md

Key reference files:
@services/geminiService.ts (current implementation to wrap)
@types.ts (AIProvider type already exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AIProviderInterface and error types</name>
  <files>services/aiProvider.ts</files>
  <action>
Create `services/aiProvider.ts` with:

1. **AIErrorCode type** - Union of error codes:
   - 'RATE_LIMIT' (429 - too many requests)
   - 'QUOTA_EXCEEDED' (429 - billing/usage limit)
   - 'AUTH_ERROR' (401/403 - invalid key)
   - 'SERVER_ERROR' (500/503/529 - provider issues)
   - 'NETWORK_ERROR' (connection failed)
   - 'PROVIDER_NOT_SUPPORTED' (OpenAI in browser)
   - 'PARSE_ERROR' (response parsing failed)
   - 'UNKNOWN_ERROR' (catch-all)

2. **AIProviderError class** extending Error:
   - `userMessage: string` - User-friendly message
   - `code: AIErrorCode` - Machine-readable code
   - `originalError?: unknown` - Original error for debugging
   - Constructor sets `this.name = 'AIProviderError'`

3. **USER_ERROR_MESSAGES** - Record<AIErrorCode, string> mapping codes to user-friendly messages:
   - RATE_LIMIT: "Too many requests. Please wait a moment and try again."
   - QUOTA_EXCEEDED: "Usage limit reached. Please check your billing settings with your AI provider."
   - AUTH_ERROR: "Invalid API key. Please check your settings."
   - SERVER_ERROR: "The AI service is temporarily unavailable. Please try again later."
   - NETWORK_ERROR: "Unable to connect. Please check your internet connection."
   - PROVIDER_NOT_SUPPORTED: "This AI provider is not available for browser use. Please select Gemini or Claude."
   - PARSE_ERROR: "Failed to process the AI response. Please try again."
   - UNKNOWN_ERROR: "Something went wrong. Please try again."

4. **AIProviderInterface** - Interface all providers implement:
   ```typescript
   interface AIProviderInterface {
     generateLessonSlides(rawText: string, pageImages?: string[]): Promise<Slide[]>;
     generateSlideImage(imagePrompt: string, layout?: string): Promise<string | undefined>;
     generateResourceImage(imagePrompt: string): Promise<string | undefined>;
     generateQuickQuestion(slideTitle: string, slideContent: string[], difficulty: 'Grade C' | 'Grade B' | 'Grade A'): Promise<string>;
     reviseSlide(slide: Slide, instruction: string): Promise<Partial<Slide>>;
     generateContextualSlide(lessonTopic: string, userInstruction: string, prevSlide?: Slide, nextSlide?: Slide): Promise<Slide>;
     generateExemplarSlide(lessonTopic: string, prevSlide: Slide): Promise<Slide>;
     generateLessonResources(lessonText: string, slideContext: string): Promise<LessonResource[]>;
     generateImpromptuQuiz(slides: Slide[], currentIndex: number, numQuestions?: number): Promise<QuizQuestion[]>;
   }
   ```

5. **createAIProvider factory** function:
   - Takes `{ provider: AIProvider, apiKey: string }`
   - Returns AIProviderInterface
   - Switch on provider:
     - 'gemini' -> new GeminiProvider(apiKey)
     - 'claude' -> new ClaudeProvider(apiKey)
     - 'openai' -> throw AIProviderError with PROVIDER_NOT_SUPPORTED

Import Slide, LessonResource from '../types'. Import QuizQuestion from './geminiService' (will be moved later).
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>aiProvider.ts exports AIProviderInterface, AIProviderError, AIErrorCode, createAIProvider, USER_ERROR_MESSAGES</done>
</task>

<task type="auto">
  <name>Task 2: Create GeminiProvider wrapping existing service</name>
  <files>services/providers/geminiProvider.ts</files>
  <action>
Create `services/providers/` directory and `geminiProvider.ts`:

1. Import AIProviderInterface and AIProviderError from '../aiProvider'
2. Import all functions from '../geminiService'
3. Import types (Slide, LessonResource) from '../../types'
4. Import QuizQuestion from '../geminiService'

Create GeminiProvider class implementing AIProviderInterface:

```typescript
export class GeminiProvider implements AIProviderInterface {
  constructor(private apiKey: string) {
    // Store API key for later use
    // Note: Current geminiService uses process.env.API_KEY
    // We'll update geminiService to accept apiKey parameter in Plan 3
  }

  // For now, wrap existing functions directly
  // They still use process.env.API_KEY internally
  // Plan 3 will refactor to use this.apiKey

  async generateLessonSlides(rawText: string, pageImages?: string[]): Promise<Slide[]> {
    return geminiGenerateLessonSlides(rawText, pageImages || []);
  }

  async generateSlideImage(imagePrompt: string, layout?: string): Promise<string | undefined> {
    return geminiGenerateSlideImage(imagePrompt, layout);
  }

  // ... implement all 9 methods, each wrapping the gemini function
}
```

Wrap all 9 functions from geminiService. Each method simply delegates to the corresponding gemini function.

Error handling: Wrap each call in try/catch. If error is already AIProviderError, rethrow. Otherwise, wrap in AIProviderError with UNKNOWN_ERROR code. This ensures consistent error types.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>GeminiProvider class exists and implements all 9 methods of AIProviderInterface</done>
</task>

<task type="auto">
  <name>Task 3: Create Claude and OpenAI provider stubs</name>
  <files>services/providers/claudeProvider.ts, services/providers/openaiProvider.ts</files>
  <action>
**Create claudeProvider.ts:**

```typescript
import { AIProviderInterface, AIProviderError } from '../aiProvider';
import { Slide, LessonResource } from '../../types';
import { QuizQuestion } from '../geminiService';

export class ClaudeProvider implements AIProviderInterface {
  constructor(private apiKey: string) {}

  // Placeholder - will be implemented in Plan 2
  async generateLessonSlides(rawText: string, pageImages?: string[]): Promise<Slide[]> {
    throw new AIProviderError(
      'Claude provider not yet implemented',
      'UNKNOWN_ERROR'
    );
  }

  // ... all 9 methods throw same error
}
```

All methods throw AIProviderError with "Claude provider not yet implemented" message.

**Create openaiProvider.ts:**

```typescript
import { AIProviderInterface, AIProviderError, USER_ERROR_MESSAGES } from '../aiProvider';
import { Slide, LessonResource } from '../../types';
import { QuizQuestion } from '../geminiService';

export class OpenAIProvider implements AIProviderInterface {
  constructor(private apiKey: string) {
    // Throw immediately in constructor - OpenAI doesn't work in browser
    throw new AIProviderError(
      USER_ERROR_MESSAGES.PROVIDER_NOT_SUPPORTED,
      'PROVIDER_NOT_SUPPORTED'
    );
  }

  // These methods will never be called (constructor throws)
  // but TypeScript requires them for interface compliance
  async generateLessonSlides(): Promise<Slide[]> { throw new Error('unreachable'); }
  async generateSlideImage(): Promise<string | undefined> { throw new Error('unreachable'); }
  // ... stub all methods
}
```

OpenAI provider throws in constructor because CORS blocks all browser requests.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Both provider files exist, implement AIProviderInterface, and have appropriate error behavior</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Compile check**: `npx tsc --noEmit` passes
2. **Structure check**: `ls services/providers/` shows geminiProvider.ts, claudeProvider.ts, openaiProvider.ts
3. **Export check**: aiProvider.ts exports all required types and functions
4. **Interface alignment**: All three providers implement the same 9-method interface
</verification>

<success_criteria>
1. AIProviderInterface defines all 9 AI functions
2. AIProviderError provides unified error handling with user-friendly messages
3. createAIProvider factory returns correct provider based on type
4. GeminiProvider wraps existing geminiService (temporary delegation)
5. ClaudeProvider exists as placeholder (not implemented yet)
6. OpenAIProvider throws PROVIDER_NOT_SUPPORTED immediately
7. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-provider-ai/02-01-SUMMARY.md`
</output>
