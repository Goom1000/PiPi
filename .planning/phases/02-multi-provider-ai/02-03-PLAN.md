---
phase: 02-multi-provider-ai
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - services/geminiService.ts
  - App.tsx
  - components/PresentationView.tsx
  - components/ResourceHub.tsx
autonomous: false

must_haves:
  truths:
    - "App uses provider from settings, not hardcoded Gemini"
    - "Loading screen shows provider name (Generating with Gemini/Claude...)"
    - "Switching providers in settings works without losing presentation"
    - "API errors show user-friendly modal with dismiss button"
    - "Rate limit and quota errors include specific guidance"
  artifacts:
    - path: "App.tsx"
      provides: "Provider integration with settings"
      contains: "createAIProvider"
    - path: "services/geminiService.ts"
      provides: "Functions accepting apiKey parameter"
      contains: "apiKey: string"
  key_links:
    - from: "App.tsx"
      to: "hooks/useSettings.ts"
      via: "useSettings hook"
      pattern: "useSettings\\(\\)"
    - from: "App.tsx"
      to: "services/aiProvider.ts"
      via: "createAIProvider factory"
      pattern: "createAIProvider\\("
---

<objective>
Wire the provider system into the app, replacing hardcoded Gemini calls with settings-based provider selection.

Purpose: This is the integration phase that makes multi-provider support real. Users can now use their chosen provider, see which provider is working, and receive helpful error messages.

Output: App.tsx, PresentationView.tsx, and ResourceHub.tsx use provider from settings. Loading states show provider name. Errors display in modal.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-multi-provider-ai/02-CONTEXT.md
@.planning/phases/02-multi-provider-ai/02-01-SUMMARY.md
@.planning/phases/02-multi-provider-ai/02-02-SUMMARY.md

Key files:
@App.tsx (main integration point)
@components/PresentationView.tsx (quiz/question generation)
@components/ResourceHub.tsx (resource generation)
@services/geminiService.ts (refactor to accept apiKey)
@hooks/useSettings.ts (source of provider/apiKey)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor geminiService to accept apiKey parameter</name>
  <files>services/geminiService.ts</files>
  <action>
Modify all functions in geminiService.ts to accept apiKey as first parameter instead of using process.env.API_KEY.

**For each function:**

1. Add `apiKey: string` as first parameter
2. Remove `if (!process.env.API_KEY)` checks
3. Replace `process.env.API_KEY` with `apiKey` parameter
4. Keep all prompts and logic identical

**Example transformation:**
```typescript
// BEFORE
export const generateLessonSlides = async (rawText: string, pageImages: string[] = []): Promise<Slide[]> => {
  if (!process.env.API_KEY) {
    throw new Error("API Key is missing...");
  }
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  ...
}

// AFTER
export const generateLessonSlides = async (apiKey: string, rawText: string, pageImages: string[] = []): Promise<Slide[]> => {
  const ai = new GoogleGenAI({ apiKey });
  ...
}
```

Apply this pattern to all 9 exported functions:
- generateLessonSlides
- generateSlideImage
- generateResourceImage
- generateQuickQuestion
- reviseSlide
- generateContextualSlide
- generateExemplarSlide
- generateLessonResources
- generateImpromptuQuiz

Keep QuizQuestion interface export unchanged.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>All 9 functions accept apiKey as first parameter</done>
</task>

<task type="auto">
  <name>Task 2: Update GeminiProvider to pass apiKey</name>
  <files>services/providers/geminiProvider.ts</files>
  <action>
Update GeminiProvider to pass this.apiKey to all geminiService function calls.

**Example:**
```typescript
async generateLessonSlides(rawText: string, pageImages?: string[]): Promise<Slide[]> {
  try {
    return await geminiGenerateLessonSlides(this.apiKey, rawText, pageImages || []);
  } catch (e) {
    if (e instanceof AIProviderError) throw e;
    throw new AIProviderError(USER_ERROR_MESSAGES.UNKNOWN_ERROR, 'UNKNOWN_ERROR', e);
  }
}
```

Update all 9 method implementations to pass this.apiKey as first argument.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>GeminiProvider passes apiKey to all geminiService functions</done>
</task>

<task type="auto">
  <name>Task 3: Wire provider into App.tsx with error modal</name>
  <files>App.tsx</files>
  <action>
**1. Update imports:**
```typescript
// Remove direct geminiService imports
// import { generateLessonSlides, ... } from './services/geminiService';

// Add provider imports
import { createAIProvider, AIProviderError, AIProviderInterface } from './services/aiProvider';
import { useSettings } from './hooks/useSettings';
```

**2. Add settings hook and provider creation:**
```typescript
function App() {
  const [settings] = useSettings();

  // Create provider instance (memoized to avoid recreation on every render)
  const provider = useMemo<AIProviderInterface | null>(() => {
    if (!settings.apiKey) return null;
    try {
      return createAIProvider({ provider: settings.provider, apiKey: settings.apiKey });
    } catch (e) {
      // OpenAI will throw here - show error
      if (e instanceof AIProviderError) {
        setError(e.userMessage);
      }
      return null;
    }
  }, [settings.provider, settings.apiKey]);
  ```

**3. Add error modal state:**
```typescript
const [errorModal, setErrorModal] = useState<{ title: string; message: string } | null>(null);
```

**4. Update handleGenerate to use provider:**
```typescript
const handleGenerate = async () => {
  if (!provider) {
    setErrorModal({
      title: 'API Key Required',
      message: 'Please configure your AI provider in Settings before generating slides.'
    });
    return;
  }

  setIsGenerating(true);
  setAppState(AppState.PROCESSING_TEXT);
  setError(null);

  try {
    const generatedSlides = await provider.generateLessonSlides(lessonText, pageImages);
    // ... rest of existing logic
  } catch (err) {
    if (err instanceof AIProviderError) {
      setErrorModal({ title: 'Generation Failed', message: err.userMessage });
    } else {
      setErrorModal({ title: 'Error', message: 'An unexpected error occurred.' });
    }
    setAppState(AppState.INPUT);
  } finally {
    setIsGenerating(false);
  }
};
```

**5. Update all AI function calls to use provider:**
- generateSlideImage -> provider.generateSlideImage
- reviseSlide -> provider.reviseSlide
- generateExemplarSlide -> provider.generateExemplarSlide

**6. Update loading state to show provider name:**
```typescript
// In PROCESSING_TEXT state
<p className="text-slate-500 mt-2">
  Generating with {settings.provider === 'gemini' ? 'Gemini' :
                   settings.provider === 'claude' ? 'Claude' : 'AI'}...
</p>
```

**7. Add error modal component (at end of return, before closing div):**
```typescript
{errorModal && (
  <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
    <div className="bg-white dark:bg-slate-800 rounded-2xl p-6 max-w-md mx-4 shadow-2xl">
      <h3 className="text-lg font-bold text-slate-800 dark:text-white mb-2">
        {errorModal.title}
      </h3>
      <p className="text-slate-600 dark:text-slate-300 mb-6">
        {errorModal.message}
      </p>
      <div className="flex gap-3 justify-end">
        <button
          onClick={() => { setErrorModal(null); setShowSettings(true); }}
          className="px-4 py-2 text-sm font-medium text-indigo-600 dark:text-amber-400 hover:underline"
        >
          Open Settings
        </button>
        <button
          onClick={() => setErrorModal(null)}
          className="px-4 py-2 bg-indigo-600 dark:bg-amber-500 text-white dark:text-slate-900 rounded-lg font-medium hover:opacity-90"
        >
          OK
        </button>
      </div>
    </div>
  </div>
)}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`. App starts: `npm run dev`</verify>
  <done>App.tsx uses provider from settings, shows provider name in loading, displays error modal</done>
</task>

<task type="auto">
  <name>Task 4: Wire provider into PresentationView and ResourceHub</name>
  <files>components/PresentationView.tsx, components/ResourceHub.tsx</files>
  <action>
These components need access to the provider. Options:
1. Pass provider as prop (recommended for simplicity)
2. Use context (overkill for this app)

**Update PresentationView.tsx:**

1. Add provider prop to component:
```typescript
interface PresentationViewProps {
  slides: Slide[];
  onExit: () => void;
  studentNames: string[];
  initialSlideIndex: number;
  provider: AIProviderInterface | null;  // Add this
}
```

2. Update function calls:
```typescript
// generateQuickQuestion
const q = provider
  ? await provider.generateQuickQuestion(currentSlide.title, currentSlide.content, level)
  : 'AI not configured';

// generateImpromptuQuiz
const data = provider
  ? await provider.generateImpromptuQuiz(slides, currentIndex, numQuestions)
  : [];
```

3. Handle errors with try/catch showing user-friendly message.

**Update ResourceHub.tsx:**

1. Add provider prop:
```typescript
interface ResourceHubProps {
  lessonText: string;
  slideContext: string;
  onClose: () => void;
  provider: AIProviderInterface | null;  // Add this
}
```

2. Update generateLessonResources call:
```typescript
const result = provider
  ? await provider.generateLessonResources(lessonText, slideContext)
  : [];
```

3. Handle errors gracefully.

**Update App.tsx to pass provider prop:**
```typescript
<PresentationView
  slides={slides}
  onExit={() => setAppState(AppState.EDITING)}
  studentNames={studentNames}
  initialSlideIndex={presentationStartIndex}
  provider={provider}  // Add this
/>

<ResourceHub
  lessonText={lessonText}
  slideContext={JSON.stringify(slides)}
  onClose={() => setShowResourceHub(false)}
  provider={provider}  // Add this
/>
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>PresentationView and ResourceHub use provider prop for AI calls</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete multi-provider integration:
- Provider selection from settings
- Loading state shows provider name
- Error modal with user-friendly messages
- All AI features work with selected provider
  </what-built>
  <how-to-verify>
1. **Gemini flow:**
   - Set Gemini as provider in Settings with valid API key
   - Upload a PDF or paste lesson text
   - Click "Generate Slideshow"
   - Verify loading says "Generating with Gemini..."
   - Verify slides generate successfully

2. **Claude flow:**
   - Switch to Claude in Settings with valid API key
   - Generate slides again
   - Verify loading says "Generating with Claude..."
   - Verify slides generate (content may differ slightly)

3. **Error handling:**
   - Use invalid API key
   - Try to generate
   - Verify error modal appears with friendly message
   - Verify "Open Settings" button works

4. **OpenAI rejection:**
   - Try to select OpenAI (if validation allows)
   - Verify appropriate error message about browser support

5. **Provider switching:**
   - Generate slides with one provider
   - Switch to different provider in Settings
   - Verify slides are NOT lost
   - Generate new slides (appends or replaces per existing behavior)

6. **Quiz/Questions:**
   - Enter presentation mode
   - Test quick question generation
   - Test impromptu quiz
   - Verify both work with selected provider
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Compile check**: `npx tsc --noEmit` passes
2. **Runtime check**: `npm run dev` starts without errors
3. **Settings integration**: Provider and apiKey from useSettings used throughout
4. **Loading state**: Shows correct provider name
5. **Error handling**: AIProviderError displays in modal with user-friendly message
6. **No regressions**: Existing Gemini functionality works as before
</verification>

<success_criteria>
1. User can generate slides using Gemini, Claude, or OpenAI (whichever configured)
2. User can switch providers without losing current presentation
3. API errors display user-friendly messages
4. Rate limit and quota errors include specific guidance
5. Loading screen shows provider name
6. All AI features work (slides, images, quiz, questions, resources)
7. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-provider-ai/02-03-SUMMARY.md`
</output>
